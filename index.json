[{"content":"观察者 - 被观察者是一个常见的设计模式.\n这里考虑一种场景: 被观察者是报刊, 观察者是订阅报刊的人. 一旦有新闻, 订阅者都可以收到报刊的通知.\n定义消息, 观察者和被观察者 消息与EventArgs 第一步是定义消息的格式, 以及观察者和被观察者的行为.\n1 2 3 4 5  public class NotifyEventArgs : EventArgs { public string Info { get; set; } = string.Empty; public DateTime Time { get; set; } }   首先定义消息, 这里继承了EventArgs. C#在语言上就提供了对消息的的支持, 其中EventArgs 包装了消息, EventHandler 包装了一个delegate, 抽象了处理EventArg的逻辑, 也就是观察者收到消息之后需要做的事情. 下一小节在观察者的接口中就定义了这个delegate的行为.\n为了简单起见, 这里消息就只包含两个内容: 消息本身以及消息发出的时间.\n观察者接口 1 2 3 4  public interface IObserver { public void NotifyEventHandler(object? notifier, NotifyEventArgs args); }   观察者只需要做一件事, 就是收到消息之后做他想做的事情. 这里函数签名与EventHandler一致, 被观察者会把它自身传给第一个参数供观察者使用, 第二个参数是NotifyEventArgs, 就是消息内容.\n被观察者接口 1 2 3 4 5  public interface IObservable { public void Register(IObserver observer); public void OnNotified(NotifyEventArgs args); }   被观察者需要做两件事:\n Register: 订阅观察者 需要通知观察者的时候, 调用OnNotified, 并且传入消息  被观察者实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Observable : IObservable { internal event EventHandler\u0026lt;NotifyEventArgs\u0026gt; NotifyEventHandlers = delegate {}; public virtual void OnNotified(NotifyEventArgs args) =\u0026gt; NotifyEventHandlers(this, args); public void Register(IObserver observer) { this.NotifyEventHandlers += observer.NotifyEventHandler; } public void Publish() { var args = new NotifyEventArgs { Info = $\u0026#34;[Breaking News!]\u0026#34;, Time = DateTime.Now }; OnNotified(args); } public override string ToString() =\u0026gt; \u0026#34;New York Times\u0026#34;; }    NotifyEventHandlers 可以视为一个集合, 保存了所有观察者注册的行为(delegate), 在需要发送消息的时候, 所有行为都会被依次调用, 这样观察者们会被依次通知. OnNotified调用NotifyEventHandlers里注册的行为. Register将观察者的行为添加到NotifyEventHandlers中. Publish构造EventArgs并触发OnNotified, 发送消息给所有观察者.  观察者实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class SubscriberAlice : IObserver { public string Name = \u0026#34;Alice\u0026#34;; public void NotifyEventHandler(object? notifier, NotifyEventArgs args) { Console.WriteLine($\u0026#34;{this.Name} received {args.Info} from {notifier?.ToString()} at {args.Time}.\u0026#34;); } } public class SubscriberBob : IObserver { public string Name = \u0026#34;Bob\u0026#34;; public void NotifyEventHandler(object? notifier, NotifyEventArgs args) { Console.WriteLine($\u0026#34;{this.Name} received {args.Info} from {notifier?.ToString()} at {args.Time}.\u0026#34;); } }   构造了两个观察者, Alice和Bob, 他们做的事情就是把收到的消息打印出来.\n启动程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Program { static void Main(string[] args) { // 初始化被观察者  var notifier = new Observable(); // 初始化观察者  var alice = new SubscriberAlice(); var bob = new SubscriberBob(); // 注册观察者  notifier.Register(alice); notifier.Register(bob); // 通知观察者  notifier.Publish(); } }   程序输出\n1 2  Alice received [Breaking News!] from New York Times at 8/30/2022 3:37:14 PM. Bob received [Breaking News!] from New York Times at 8/30/2022 3:37:14 PM.   Reference Observer Design Pattern | Microsoft Docs\nHow to: Raise and Consume Events | Microsoft Docs\n","description":"C# Observer Pattern Tutorial","id":0,"section":"blogs","tags":["Observer"],"title":"观察者模式","uri":"/blogs/observer-pattern/"},{"content":"https://leetcode.com/problems/trapping-rain-water/\n设第$i$个bar的高度为$h_i$, 其蓄水量为$v_i$, 一共有$n$个bar,\n对于每一个位置，考虑所有可能的左右bar，计算每一对可以拦截的水量，而每一对拦截水量是$\\min(h_l, h_r) - h_i$\n所有可能的围挡方式中，最高值就是答案，即\n$$\\max\\limits_{0\\leq l\u0026lt;i\u0026lt;r\u0026lt;n} (\\min(h_l, h_r) - h_i) = \\min (\\max\\limits_{0\\leq l\u0026lt;i} h_l, \\max\\limits_{i\u0026lt;r\u0026lt;n} h_r) - h_i$$\n由此可知，对于任意一个bar，它左边最高的bar和右边最高的bar中比较低的那个决定了蓄水量.\n\u0026ldquo;水位\u0026quot;法 对此, 网络上有一个非常直观的的解法：\n想象水从两边流向中间, 水位在逐渐上升, 水会逐渐淹没比较低的bar,并且在淹没其之后流向相邻的bar, 从两边逐渐向中间蔓延.\n设水位高度为$level$, 并且水流向了$h_j$.\n $level \u0026gt; h_j$, 水位比bar高, 水会淹没$h_j$, 此时$j$位置可以拦截的水量即为$v_j = level - h_j$. 证明: 无论水是从左边还是右边流向位置$j$的, 它一定得先漫过左右两边最高的bar中比较低的bar, 否则不能流到此位置. $level \\leq h_j$, 那么水平面遇到了更高的bar, 它不会容纳水, 即$v_j = 0$. 因为水从某一侧来就说明$h_j$的高度比那一侧最高的bar更高.  优先队列解 维护一个优先队列, 其中包含了水平面接触到但是尚未浸没的bar, 随着水位的上升, 有以下步骤\n水位为$0$, 左右两边的bar入队列, 作为初始状态. 最小值出队列, $h_i = q.pop()$. 这代表水位需要浸没该bar 更新水位,\na. 如果$level \\geq h_i$, 说明水位已经高过该bar, 不用更新水位值.\nb. 如果$level \u0026lt; h_i$, 说明水位需要涨到该bar的高度才能浸没它, 更新水位值.\nc. 综上所述, $level = max(level, h_i)$ 浸没$h_i$之后, 水开始探索和$h_i$相邻的bar, 设为$h_{next}$,\na. 若$h_{next}$没有入过队列(未被水接触), 将$h_{next}$入队列, 说明水流至此.\nb. 若$h_{next} \u0026lt; level$, 说明水流至此, 并且水位没过$h_{next}$, 计算蓄水量$v_i = level - h_{next}$ 重复1~3步骤直至队列为空.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  int visited[20001]; int trap_heap(vector\u0026lt;int\u0026gt;\u0026amp; height) { // 优先队列的数据结构是 {index, height} 分别记录了bar的位置和高度  auto cmp_height = [](pair\u0026lt;int, int\u0026gt; a, pair\u0026lt;int, int\u0026gt; b) {return a.second \u0026gt; b.second;}; priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, decltype(cmp_height)\u0026gt; q(cmp_height); // 设定初始状态, visited记录了该bar是否入过队列.  int level = 0; int v = 0; memset(visited, 0, sizeof(visited)); q.push({0, height[0]}); q.push({height.size()-1, height[height.size()-1]}); visited[0] = 1; visited[height.size()-1] = 1; while (!q.empty()) { int i = q.top().first; int h = q.top().second; // 最小值出队列  q.pop(); level = max(level, h); // 更新水位  int neighbours[2] = {i-1, i+1}; for (int next : neighbours) { // 遍历邻居  if (next \u0026gt;= 0 \u0026amp;\u0026amp; next \u0026lt; height.size() \u0026amp;\u0026amp; !visited[next]) { // 边界检查, 且已经入过队列的不可以再入队列.  visited[next] = 1; if (level \u0026gt; height[next]) { // 水位高于next  v += level - height[next]; } q.push({next, height[next]}); } } } return v; }   双指针解 双指针$l, r$从两边向中间遍历, 双指针其实就是水位法中优先队列里的两个元素. 双指针的移动顺序, 其实就是水浸没bar的顺序. 所以逻辑是完全一致的.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int l = 0; int r = height.size() - 1; // l和r对应队列中的index  int lmax = 0; int rmax = 0; int v = 0; // lmax和rmax代表了左右两边水位的高度, 对应level  while (l \u0026lt;= r) { int hl = height[l]; int hr = height[r]; // hl和hr对应队列中的height  if (hl \u0026lt;= hr) { // 左边水位比较低, 先处理左边  lmax = max(lmax, hl); // 更新水位  if (lmax \u0026gt; hl) { v += lmax - hl; // 水位浸没hl  } l++; // 对应hl入队列  } else { // 右边水位比较低, 先处理右边  rmax = max(rmax, hr); if (rmax \u0026gt; hr) { v += rmax - hr; // 水位浸没hr  } r--; // 对应hr入队列  } } return v; } };   二维拓展 Extend: https://leetcode.com/problems/trapping-rain-water-ii/\n这道题拓展到了2维，其实使用\u0026quot;水位法\u0026quot;依然可解。\n想象水从四周流向中间，水位逐渐上升，每当水位升至与某一个$h_i$齐平的时候，它就会\u0026quot;溢出\u0026quot;并且蔓延到和$h_i$接壤的位置，此时需要检查水可不可以\u0026quot;漫\u0026quot;过去。如果接壤的$h_j \u0026lt; h_i$，$h_j$之上可以容纳水的体积就确定为$h_i - h_j$. 因为对$j$来说，在已经把它包围的拓扑里，最低的值是$h_i$\n所以和上一题把两边的bar入栈类似的, 先把最外围一圈入栈, 然后和1维情况一样了. 演示动画\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  class Solution { public: int visited[201][201]; int drow[4] = {0, -1, 0, 1}; // clockwise  int dcol[4] = {-1, 0, 1, 0}; int trapRainWater(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; heightMap) { // 堆中元素的结构: {{row, col}, height}  int nrow = heightMap.size(); int ncol = heightMap[0].size(); auto cmp_height = [](pair\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; a, pair\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt; b) {return a.second \u0026gt; b.second;}; priority_queue\u0026lt;pair\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt;, vector\u0026lt;pair\u0026lt;pair\u0026lt;int, int\u0026gt;, int\u0026gt;\u0026gt;, decltype(cmp_height)\u0026gt; q(cmp_height); // 初始化水平面和水量  int level = 0; int volume = 0; memset(visited, 0, sizeof(visited)); // 第一行和最后一行入队列  for (int col = 0; col \u0026lt; ncol; col++) { q.push({{0, col}, heightMap[0][col]}); // first row  q.push({{nrow-1, col}, heightMap[nrow-1][col]}); // last row  visited[0][col] = 1; visited[nrow-1][col] = 1; } // 第一列和最后一列入队列  for (int row = 1; row \u0026lt; nrow-1; row++) { // 跳过第一行和最后一行已经入队列的元素  q.push({{row, 0}, heightMap[row][0]}); q.push({{row, ncol-1}, heightMap[row][ncol-1]}); visited[row][0] = 1; visited[row][ncol-1] = 1; } while (!q.empty()) { pair\u0026lt;int, int\u0026gt; coord = q.top().first; int h = q.top().second; q.pop(); level = max(level, h); for (int i = 0; i \u0026lt; 4; i++) { // 遍历上下左右四个位置  pair\u0026lt;int, int\u0026gt; next = {coord.first + drow[i], coord.second + dcol[i]}; int next_height = heightMap[next.first][next.second]; if (next.first \u0026gt;= 0 \u0026amp;\u0026amp; next.first \u0026lt; nrow \u0026amp;\u0026amp; next.second \u0026gt;=0 \u0026amp;\u0026amp; next.second \u0026lt; ncol \u0026amp;\u0026amp; !visited[next.first][next.second]) { visited[next.first][next.second] = 1; if (level \u0026gt; next_height) { volume += level - next_height; } q.push({next, next_height}); } } } return volume; } };   ","description":"","id":1,"section":"playground","tags":null,"title":"Trapping Rain Water","uri":"/playground/trapping-rain-water/"},{"content":" Time to mix drinks and change lives\n VA-11 HALL-A VA-11 HALL-A是2016年6月21日登陆Steam的一款单人AVG游戏, 在游戏里你需要做的事情很少. 简单来说, 就是调酒, 听客人吐槽以及吐槽客人, 捎带每天晚上去购物满足主角Jill的消费欲, 以及赚够足够的房租不至于流落街头.\n因为一些游戏之内以及之外的故事, 它意外地获得了非常好的评价, 以及很多meme. 在此就不展开了, 有兴趣可以自己搜搜(毕竟本文也不是来推销游戏的) 单纯从游戏内容来看, 8bit风格十足的美术和音乐, 鲜活的人物刻画, 以及充斥着整个游戏的(语文不好不知道如何形容, 4chan味?)构造出一个十分有沉浸感的世界.\n当然, 既然是赛博朋克, 反乌托邦那套世界观拿来就用了. 巧在现代互联网社区的阴暗角落(没错,又是4chan)里充斥着的元素和这样的世界观异常相配, 产生了奇妙的化学反应, 这样虚拟世界/网络世界/现实的模糊也是沉浸感的来源.\nThe cyberpunk world was born for criticism, which is far from even a fine world. There\u0026rsquo;s bitter behind the guys created the game, and it\u0026rsquo;s not their fault.\nThe idea of cyberpunk is so famous. I\u0026rsquo;m guessing some big names would feel sting in their backs while other poor guys creating, contributing, and being a part of this world.\n  一些可以跳过的无关私货  之所以对这个游戏有如此深刻的印象, 还是要回到现实, 看看当时发生了啥. 好在我有玩完游戏写review的习惯, 翻到大概是在2018年7月15日在steam写的, 根据时间来回忆一下\u0026quot;操蛋的现实\u0026quot;指的都是啥.\n1 2 3 4 5 6 7 8 9 10 11  很高兴能暂时脱离这操蛋的现实,在vallhala里呆一会, 体验他们更操蛋的生活. 这很赛博朋克. 希望有一家这样的酒吧可以去, 虽然我不能喝酒, 但可以Sugar Rush嘛 最后, 太真实了, 买买买还是很容易导致交不起房租的! 下面是私货 1. Rad Shiba(有提到是高智商写程序的犬类) -\u0026gt; Ein 2. Jamie曾经提到的传奇杀手外号Black Dog -\u0026gt; Jet的外号 3. Alma -\u0026gt; Ed(肤色很像, 都是黑客, 身材嘛...who knows?) 4. 有一款酒名为Crevice Spike 5. 月球爆炸了!(cb世界观) 作为cb粉真的被爽到了.   2018年7月, 研究生二年级暑假, 我刚好结束为期1年的实习, 离开上海回家, 准备秋招踏上社畜之路. 那个时候完全没有职场经验, 属于走进面试间两腿就打颤的水平, 很方. (搞笑的是后来面多了才知道根本没有面试间, 成百上千人挤在一起 搬个小桌子和你面对面都很奢侈了)\n不过刚到家屁股还没坐热, 我爹晕倒在了家里, 感觉这种关头人会觉得事情一下子就全都来的很快: 打120, 进急诊室, 医生就让我签责任书, 使用溶栓药. 因为这玩意会清除血栓, 但也有一定概率造成脑出血, 所以我要为我的决定负责. 面对的是自己的亲爹, 这种感觉难以描述. 打完效果未卜转到南京省院, 在医院打地铺通宵等医生消息. 好在之后恢复得很好, 甚至都没有留下什么后遗症, 并且也没有再复发过. 对坚持锻炼的我爹报以崇高的敬意.\n后来我在准备面试的闲暇时间打完了这游戏, 经历了这一切求职时心态反而很好, 感觉自己也成长了一些, 不过代价还是太大了, 不如不要. 游戏如果足够好, 就能让人暂时从现实脱身, 躲在安全的壳儿里神游一会(其实好电影也一样). 四处奔波面试的我大概是很珍惜这段时间了.\n想起自己16年本科毕业之后不想继续读基础学科了, 也逃避就业, 一个人在南大和园租了个毛坯房, 闷头准备了一年考研, 当时印象最深的是看完了7部jojo, 玩了几遍Undertale. 白天见的人太少了有点恍惚, 晚上就去GTA5里上街瞎逛, 感觉都是很相似的经历.\n  Ben\u0026rsquo;s Secret 去年我在b站发现一位调酒师UP神秘金针菇先生发了游戏里酒的复刻(当然不能真按游戏里的配方来, 需要要调酒师自己去按照酒的属性创作, 所以不会调酒就别瞎折腾了), 发现酒吧在南京, 就收藏了希望哪天有机会去体验一下. 所以, 2021年6月的最后一个周末, 冒着夜里的小雨, 我终于有机会前去拜访一下. 这还是我第一次去酒吧\u0026hellip;本人基本上不喝酒, 以前在实验室闻了太多乙醇, 和巴普洛夫的狗子一样训练出了ptsd. 哈哈\n酒吧大门 内景 漫画  酒吧门口的招牌. 其实藏得很深, 门口是烤肉店. 很有设计感的招牌.  排排坐就满啦. 有全套eva和王牌酒保漫画可看, 当然也有调酒文化相关的书籍供阅览.           贞本义行老师的EVA. 漫画作者和我一样是个丽党, 我喜欢这个版本的结局 王牌酒保是调酒师入行的引子呢. 不过依他所言, 现实要是和漫画里一样, 酒吧就要关门咯. 所以说漫画就是漫画, 啊哈哈.       'use strict'; var containerId = JSON.parse(\"\\\"fc16b87663f7c597\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  幸运地找到了UP主, 表明了是他的粉丝!(其实是假粉, 视频都没看完, 后来果然暴露了, hiahia), 点了两杯女性化的酒 - Sugar Rush, Fluffy Dream以及一杯黄油啤酒 (拍照过于激动还打翻了一杯, 罪过罪过)\nSugar-Rush Fluffy-Dream ButterBeer  经典的Sugar Rush, 不含酒精, 杯子真的很迷你, 有那种女性化的可爱感觉  Fluffy Dream, 微酸, 很柔和的口感, 清爽  黄油啤酒, 肉桂和麦芽香气让这款酒特别上头    'use strict'; var containerId = JSON.parse(\"\\\"807c603b01a1fb93\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; } \n其实还有好几件意外惊喜没能多拍点记录下来(只顾吃喝了), 恰逢酒吧一位客人过生日, 我还收到了一份马卡龙和蛋糕, 希望过生日的小伙也能收到我的祝福哈. 以及给老板拍了一张Portra400, 可惜酒吧有点儿暗, 外加当时机器还没完全修好, 我自觉拍得不够完美, 希望神秘金针菇先生不介意就好哈. 顺便也给Sugar Rush拍了一张.\nSugar-Rush靓照 调酒师靓照  虽然有点暗但是很有氛围感  调酒师很亲切, 有可爱的娃娃脸, 还替我们科普了很多有趣的调酒知识    'use strict'; var containerId = JSON.parse(\"\\\"d8be99c000a31367\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  如果有机会, 下次一定带灯和脚架来拍. 感谢茜茜, 感谢调酒师先生以及酒吧里的客人们, 让我有了这次奇妙而难忘的经历.\n 尾声悄悄话 2021年了, 我的经历还要以图文这朴素的方式记录, 而不是2077里的超梦, 科技发展也太慢了吧? 什么时候能去火星啊. 望天.\n","description":"","id":2,"section":"blogs","tags":null,"title":"赛博朋克, 调酒师与现实","uri":"/blogs/va11/"},{"content":"LeetCode 174\nA False Example We demonstrate a false example to show that there is no top-down, left-right dp solution to this problem.\n We need to test all possible paths from $(0,0)$ to $(i,j)$, find the lowest bound of the path sum along each path, from start to end. (Actually the value is lowest bound + 1, which keeps the knight alive) Keep two tables, $dpSum[i][j]$ records the path sum to have $dpMin[i][j]$, which records the lowest bound upon current position along this path.  If we have both $(i-1, j)$ and $(i, j-1)$ for above two tables, do we have $dp[i][j]$ ? The answer is no. Think about it.\nSolution Actually we need to calculate at a bottom-up, right-left order. Let $dp[i][j]$ to be the lowest HP to start from $(i,j)$ to the end, we have:\n$$dp[i][j] = \\begin{cases} min(dp[i][j-1], dp[i-1][j]) - grid[i][j], \u0026amp; \\text{$min(dp[i][j-1], dp[i-1][j]) - grid[i][j] \u0026gt; 0$} \\\\ 1, \u0026amp; \\text{$min(dp[i][j-1], dp[i-1][j]) - grid[i][j] \\leq 0$} \\end{cases}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: def calculateMinimumHP(self, grid: List[List[int]]) -\u0026gt; int: n_row, n_col = len(grid), len(grid[0]) dp = [[float(\u0026#39;inf\u0026#39;)]*n_col for _ in range(n_row)] dp[n_row-1][n_col-1] = 1 - min(0, grid[n_row-1][n_col-1]) # init last row and col for i in range(n_row-2, -1, -1): need = dp[i+1][n_col-1] - grid[i][n_col-1] dp[i][n_col-1] = need if need \u0026gt; 0 else 1 for j in range(n_col-2, -1, -1): need = dp[n_row-1][j+1] - grid[n_row-1][j] dp[n_row-1][j] = need if need \u0026gt; 0 else 1 # init dp table for i in range(n_row-2, -1, -1): for j in range(n_col-2, -1, -1): need = min(dp[i+1][j], dp[i][j+1]) - grid[i][j] dp[i][j] = need if need \u0026gt; 0 else 1 return dp[0][0]   ","description":"","id":3,"section":"playground","tags":["dynamic programming"],"title":"Dungeon Game","uri":"/playground/dungeon-game/"},{"content":"LeetCode 730\nThe problem seems to be similar to Longest Palindromic Subsequence, but tt\u0026rsquo;s hard to enumerate all the subsequences since it goes to $O(2^n)$ complexity.\nActually, the distinct subsequence is similar to Distinct Subsequences II. We could use the method called Sequence Automata. Check: 序列自动机总结与例题, 序列自动机\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution: def init_next(self, s: str, a: int) -\u0026gt; List[List[int]]: n = len(s) - 1 get_next = [[0]*a for _ in range(n+1)] for i in range(n, 0, -1): for c in range(a): get_next[i-1][c] = get_next[i][c] get_next[i-1][ord(s[i])-ord(\u0026#39;a\u0026#39;)] = i return get_next def countPalindromicSubsequences(self, S: str) -\u0026gt; int: s1, s2, n, a, mod = \u0026#39; \u0026#39;+S, \u0026#39; \u0026#39;+S[::-1], len(S), 4, 10**9+7 next1, next2 = self.init_next(s1, a), self.init_next(s2, a) def dfs(i, j) -\u0026gt; int: ans = 0 for c in range(a): i_n, j_n = next1[i][c], next2[j][c] if i_n and j_n: if i_n + j_n \u0026gt; n + 1: continue if i_n + j_n \u0026lt; n + 1: ans += 1 ans = (ans + dfs(i_n, j_n)) % mod return ans + 1 return dfs(0, 0) - 1   ","description":"","id":4,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Count Different Palindromic Subsequences","uri":"/playground/count-different-palindromic-subsequences/"},{"content":"LeetCode 516\nThis is similar to Longest Palindromic Substring, but it is hard to use the expanding idea cuz the subsequence is not continuous. We can try to use the dp idea as an initial:\nLet $dp[i][j]$ to be the longest palindromic substring for $s[i, j]$, then:\n$$ dp[i][j] = \\begin{cases} dp[i+1][j-1] + 2, \u0026amp; \\text{$s[i]=s[j]$} \\\\ \\max\\lbrace dp[i][j-1], dp[i+1][j] \\rbrace, \u0026amp; \\text{$s[i] \\neq s[j]$} \\\\ 1, \u0026amp;\\text{$i=j$} \\\\ 0, \u0026amp;\\text{$i\u0026gt;j$} \\end{cases} $$\n dp[i][j-1]\u0026lt;--dp[i][j] / | / | dp[i+1][j-1] dp[i+1][j] Corner Cases There are two corner cases as listed above, $i=j$ and $i\u0026lt;j$, we need to initialize them first.\n   i\\j 0 1 2 3 4     0 1 a c f j   1 0 1 b e i   2  0 1 d h   3   0 1 g   4    0 1    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def longestPalindromeSubseq(self, s: str) -\u0026gt; int: n = len(s) if n == 0: return 0 dp = [[0]*n for _ in range(n)] # init two corner cases for i in range(n): dp[i][i] = 1 for i in range(1, n): dp[i][i-1] = 0 # filling the table for j in range(1, n): for i in range(j-1, -1, -1): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]   Backtracking Solution WIP\n","description":"","id":5,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Longest Palindromic Subsequence","uri":"/playground/longest-palindromic-subsequence/"},{"content":"leetcode 152\nThe idea is the same like Maximum Subarray, let $dp[i]$ to be the maximum product subarray value that ends at $nums[i]$, but we have some issues here:\n If $dp[i-1] = 3$, while the minimum product subarray value that ends at $i$ is $-4$ and $nums[i] = -1$, then we get $-4 \\cdot -1 \u0026gt; 3 \\cdot -1$ Apparently we need to record the minimum product subarray as well, and we compare all the values.  $$ dp[i] = \\max \\lbrace dp_{min}[i-1] \\cdot nums[i], dp_{max}[i-1] \\cdot nums[i], nums[i] \\rbrace $$\n1 2 3 4 5 6 7 8 9 10  class Solution: def maxProduct(self, nums: List[int]) -\u0026gt; int: n, max_prod = len(nums), nums[0] dp = [{\u0026#39;max\u0026#39;:0, \u0026#39;min\u0026#39;:0} for _ in range(n)] dp[0][\u0026#39;max\u0026#39;], dp[0][\u0026#39;min\u0026#39;] = nums[0], nums[0] for i in range(1, n): dp[i][\u0026#39;max\u0026#39;] = max(dp[i-1][\u0026#39;max\u0026#39;]*nums[i], dp[i-1][\u0026#39;min\u0026#39;]*nums[i], nums[i]) dp[i][\u0026#39;min\u0026#39;] = min(dp[i-1][\u0026#39;max\u0026#39;]*nums[i], dp[i-1][\u0026#39;min\u0026#39;]*nums[i], nums[i]) max_prod = max(max_prod, dp[i][\u0026#39;max\u0026#39;]) return max_prod   ","description":"","id":6,"section":"playground","tags":["dynamic programming"],"title":"Maximum Product Subarray","uri":"/playground/maximum-product-subarray/"},{"content":"leetcode 140\nThis is pretty much an easier version of Palindrome Partitioning, cuz finding a word is much easier than finding a valid palindrome substring.\nUsing a backtracking method:\n When a substring is breakable, we iterate this substring and find all possible break positions. Dfs search each possible breaks. If search ends, we find a match.  Corner Cases: We can handle the situaion which search string is '', so we can put the terminal condition in the self.breakable()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution: def breakable(self, s: str, wordDict: List[str]) -\u0026gt; bool: n = len(s) dp = [False]*(n+1) dp[0] = True for i in range(1, n+1): for n in range(i+1): if dp[n] and s[n:i] in wordDict: dp[i] = True break return dp[n] def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: n = len(s) results: List[str] = [] def search(i:int, path: List[str]): if i == n: results.append(\u0026#39; \u0026#39;.join(path)) if self.breakable(s[i:], wordDict): for j in range(i, n): sub_str = s[i:j+1] if sub_str in wordDict: search(j+1, path+[sub_str]) search(0, []) return results   ","description":"","id":7,"section":"playground","tags":["dynamic programming","backtracking","dfs"],"title":"Word Break 2","uri":"/playground/word-break-2/"},{"content":"leetcode 139\nThis is an easy version of Longest Palindromic Substring, cuz finding a word is much easier than finding a valid palindrome substring.\nLet $dp[i]$ to be if $s[0, i]$ is a valid break, we have:\n If $s[0, n]$ is a valid break and $s[n+1, i]$ is in the dict $S$, then $s[0, i]$ is a valid break. i.e.\n$$ dp[n] \\land \\lbrace s[n+1, i] \\in S \\rbrace \\to dp[i] $$\n It looks like we need to firstly iterate the $s$, and iterate substring at each position $i$, which makes it $O(n^2)$ complexity. When we find a match in the substring, we can stop the iteration.\nCorner Cases If we check substring from $s[0, i]$, then we don\u0026rsquo;t have $dp[-1]$, we can insert a True to the $dp$ table, and be careful of the index changes:\n When indexing $dp$, $[0, n-1] \\to [1, n]$ when indexing $s$, we need to use $s[i-1]$  $$dp[i] = \\bigcap_{n=0}^{i} \\left\\lbrace dp[n] \\land \\lbrace s[n+1, i] \\in S \\rbrace \\right\\rbrace $$\n1 2 3 4 5 6 7 8 9 10 11  class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool: n = len(s) dp = [False]*(n+1) dp[0] = True for i in range(1, n+1): for n in range(i+1): if dp[n] and s[n:(i-1)+1] in wordDict: dp[i] = True break return dp[n]   ","description":"","id":8,"section":"playground","tags":["dynamic programming"],"title":"Word Break","uri":"/playground/word-break/"},{"content":"LeetCode 132\nWe need to borrow the idea from Longest Palindromic Substring, using the ad-hoc method, try to expand at each index as the center.\nLet $dp[i]$ to be the minimum cuts for $s[0, i]$, initialize it to the maximum cuts, which is $i-1$ (in 0-based indexing, it is $i$)\nBy using the expanding idea, when we get a palindrome substring $s[l, r]$, the minimum cuts for $s[0, r]$ shrinks into $dp[l-1]+1$. Iterate through all the possible palindrome substrings.\n   a b a c d d c a a a     0 1 0 1 2 2 1 2 2 2    Corner Case When i-1\u0026lt;0, i.e. we have a palindrome substring which starts from 0, e.g. s=abc, r=2, then the dp[0-1]=0, means we don\u0026rsquo;t need any cut for string abc cuz it itself is a palindrome substring.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: def minCut(self, s: str) -\u0026gt; str: n = len(s) dp = [i for i in range(n)] for i in range(n): for j in range(i+1): l, r = i-j, i+j if l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: dp[r] = min(dp[r], dp[l-1]+1 if l-1\u0026gt;=0 else 0) else: break for j in range(i+1): l, r = i-1-j, i+j if l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: dp[r] = min(dp[r], dp[l-1]+1 if l-1\u0026gt;=0 else 0) else: break return dp[-1]   ","description":"","id":9,"section":"playground","tags":["dynamic programming"],"title":"Palindrome Partitioning 2","uri":"/playground/palindrome-partitioning-2/"},{"content":"LeetCode 131\nAlthough this is similar to Longest Palindromic Substring, yet the idea is similar to Word Break 2. We use backtracking at each place it could be partitioned.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def partition(self, s: str) -\u0026gt; List[List[str]]: n = len(s) results: List[List[str]] = [] def search(i, path: List[str]): if i == n: results.append(path) for j in range(i, n): sub = s[i:j+1] if sub == sub[::-1]: search(j+1, path+[sub]) search(0, []) return results   ","description":"","id":10,"section":"playground","tags":["backtracking","dfs"],"title":"Palindrome Partitioning","uri":"/playground/palindrome-partitioning/"},{"content":"LeetCode 188\nSay you have an array for which the i-th element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\nDP Solution Let dp[i][j] to be the maximum profit to buy and sell the stock with at most i operations at t=j.\nFor any given time t, we have two options:\n Do nothing, or buy the stock, the profit remains unchanged: dp[i][j] = dp[i][j-1] Sell the stock. We must buy the stock first. Assume that we but the stock at $t \\in [0, j-1]$  We have already gained profit dp[i-1][t-1] Buy the stock: -prices[t] Sell the stock: prices[j]\nTotal profit: dp[i-1][t-1] - prices[t] + prices[j]   We need to iterate through all possible buying time:  $$ dp[i][j] = \\max \\left\\lbrace dp[i][j-1], \\max\\limits_{t \\in [0, j-1]} \\left\\lbrace dp[i-1][t-1] - p[t] \\right\\rbrace + p[j] \\right\\rbrace $$\nNotice the 2nd term, we let $M_j=\\max\\limits_{t \\in [0, j-1]} \\left\\lbrace dp[i-1][t-1] - p[t] \\right\\rbrace$ and $ m_{t} = dp[i-1][t-1] - p[t] $:\n$$ M_{j} = \\max\\limits_{t \\in [0, j-1]} \\lbrace m_{t} \\rbrace = \\max \\left\\lbrace M_{j-1}, m_{j-1} \\right\\rbrace $$\nAt each iteration $i, j$, we could calculate $m_{j}=dp[i-1][j-1]-p[j]$ for the next iteration in advance. Because in current iteration we already have the data of dp[i-1][x]. Thus we can get rid of the inner loop and calculate $M_j$ in an iterative way.\nCorner Cases We start from $i=1, j=1$ to avoid corner cases. For $i=0$ or $j=0$, $dp[i][j]=0$, so we don\u0026rsquo;t need additional init steps.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: def quickSolve(self, prices: List[int]) -\u0026gt; int: profit = 0 for i in range(1, len(prices)): if prices[i] \u0026gt; prices[i - 1]: profit += prices[i] - prices[i-1] return profit def maxProfit(self, k: int, prices: List[int]) -\u0026gt; int: if k \u0026gt;= len(prices) // 2: return self.quickSolve(prices) dp = [[0]*len(prices) for _ in range(k+1)] for i in range(1, k+1): tmp_max = -prices[0] for j in range(1, len(prices)): dp[i][j] = max(dp[i][j-1], tmp_max + prices[j]) tmp_max = max(tmp_max, dp[i-1][j-1] - prices[j]) return dp[k][-1]   ","description":"","id":11,"section":"playground","tags":["dynamic programming"],"title":"Best Time to Buy and Sell Stock Iv","uri":"/playground/best-time-to-buy-and-sell-stock-iv/"},{"content":"LeetCode 120\nThe method is identical to [Minimal Path Sum](/playground/minimal-path-sum/, only that the shape changes from rectangle to triangle.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def minimumTotal(self, triangle: List[List[int]]) -\u0026gt; int: n_row = len(triangle) dp = [[] for _ in range(n_row)] dp[0].append(triangle[0][0]) for i in range(1, n_row): for j in range(i+1): top_left = dp[i-1][j-1] if j-1\u0026gt;=0 else float(\u0026#34;inf\u0026#34;) top_right = dp[i-1][j] if j \u0026lt; len(triangle[i-1]) else float(\u0026#34;inf\u0026#34;) minimal = min(top_left, top_right) + triangle[i][j] dp[i].append(minimal) return min(dp[-1])   Notes\n Init the first element manually Init the dp table by appending instead of indexing For each element to iterate, check left bound for top left, check right bound for top right ","description":"","id":12,"section":"playground","tags":["dynamic programming"],"title":"Triangle","uri":"/playground/triangle/"},{"content":"Leetcode 115\nThis problem is quite similar to Interleaving String, but the solution is almost the same as Regular Expression Matching: we build top-down solution by backtracking, then build bottom-up solution of dp.\nIntro problem Let\u0026rsquo;s discuss a simplified problem: How to check if t is a subsequence of s? Using a greddy strategy, this would be quite straight forward:\n Iterate through s, match t in a greddy manner.\n  If t has been iterated over, we find a match. If s has been iterated over, we need to iterate over t as well, or there\u0026rsquo;s no match, search over. If not 1 or 2, we need to continue searching, skip the characters in s[0] which don\u0026rsquo;t match t[0]  1 2 3 4 5 6 7 8 9 10 11 12 13  def is_subsequence(s: str, t: str) -\u0026gt; bool: def search(i: int, j: int) -\u0026gt; bool: while i\u0026lt;len(s) and j\u0026lt;len(t) and s[i] != t[j]: i += 1 if j == len(t): return True elif i == len(s): return False else: return search(i+1, j+1) return search(0, 0)   Backtracking Borrowing the idea from last section, we need to count all of the possible match, so we can\u0026rsquo;t stop when we find a character matches, we need to skip this match and explore if there\u0026rsquo;re other possibilities to achieve a match.\nWe define search(i, j) to be the distinct subsequences for s[i:] and t[j:], despite that we search for the current match, we still goes for further possibilities in s\n1 2 3 4 5 6 7 8 9 10 11 12 13  def numDistinct(self, s: str, t: str) -\u0026gt; int: def search(i, j): while i\u0026lt;len(s) and j\u0026lt;len(t) and s[i] != t[j]: i += 1 if j == len(t): return 1 elif i == len(s): return 0 else: return search(i+1, j+1) + search(i+1, j) return search(0, 0)   Note:\n We can easily optimize time complexity by using a cache to avoid duplicate calculation. See Optimize Recursion.  Dynamic Programming WIP\n","description":"","id":13,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Distinct Subsequences","uri":"/playground/distinct-subsequences/"},{"content":"Leetcode 97\nDescription Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\nExample:\nInput: s1 = \u0026quot;aabcc\u0026quot;, s2 = \u0026quot;dbbca\u0026quot;, s3 = \u0026quot;aadbbcbcac\u0026quot; Output: true Explanation: aadbbcbcac, aadbbcbcac are all valid interpretations for the interleaving.\nNotice:\n The order of the strings cannot be changed, which indicates that we can construct s3 using s1 and s2 from their substrings. Different ways of interleaving can led to same results.  Example of constructing a string We define $dp[i][j]$ as: If $a3[0, i+j]$ can be constructed by $a1[0, i]$ and $a2[0, j]$\nWe have 2 choices to construct $a3[0, i+j+1]$: using $a1[i+1]$ or $a2[j+1]$\n1 2  if dp[i][j] and s1[i+1] == s3[i+j+1]: dp[i+1][j] = True # Use s1[i+1] to construct s3[i+j+1] if dp[i][j] and s2[j+1] == s3[i+j+1]: dp[i][j+1] = True # Use s2[j+1] to construct s3[i+j+1]   So we have 2 ways to get the needed dp[i][j]\n1 2  use_s1 = dp[i-1][j] and s1[i] == s3[i+j] use_s2 = dp[i][j-1] and s2[j] == s3[i+j]   i.e.\n1  dp[i][j] = use_s1 or use_s2   Corner Cases If $i=0, j=5$, it represents that if $a3[0, 5]$ can be constructed by $s1=\\varnothing$ and $s2[0,5]$, we only need to check that if $s2[0,5] = s3[0,5]$\nIf we use 0-based index, this situation corresponding to dp[-1][4], which is not quite convenience. Using 1-based indexing we could initialize the first row and col and then calculating the dp table from dp[1][1]\n    0 d b b c a     0 T F F F F F   a T F F F F F   a T T T T F F   b F T T F F F   c F F T T T T   c F F F T F T    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: def isInterleave(self, s1: str, s2: str, s3: str) -\u0026gt; bool: if len(s1) + len(s2) != len(s3): return False m, n = len(s1), len(s2) dp = [[False]*(n+1) for _ in range(m+1)] for i in range(n+1): # s1 is empty dp[0][i] = s2[:i] == s3[:i] for i in range(m+1): # s2 is empty dp[i][0] = s1[:i] == s3[:i] for i in range(1, m+1): for j in range(1, n+1): use_s1 = dp[i-1][j] and s1[i-1] == s3[i+j-1] use_s2 = dp[i][j-1] and s2[j-1] == s3[i+j-1] dp[i][j] = use_s1 or use_s2 return dp[-1][-1]   Note:\n Under 1-based indexing, take care of the indexing on s1, s2 and s3. ","description":"","id":14,"section":"playground","tags":["dynamic programming"],"title":"Interleaving String","uri":"/playground/interleaving-string/"},{"content":"Leetcode 639\nSame as Decode Ways, we only need to add some cases on wildcard matching, in which we could match multiple patterns for S[i]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution: def numDecodings(self, s: str) -\u0026gt; int: one = {str(k):1 for k in range(1, 10)} one.update({\u0026#39;*\u0026#39;:9}) two = {str(k):1 for k in range(10, 27)} two.update({ \u0026#39;*0\u0026#39;: 2, \u0026#39;*1\u0026#39;: 2, \u0026#39;*2\u0026#39;: 2, \u0026#39;*3\u0026#39;: 2, \u0026#39;*4\u0026#39;: 2, \u0026#39;*5\u0026#39;: 2, \u0026#39;*6\u0026#39;: 2, \u0026#39;*7\u0026#39;: 1, \u0026#39;*8\u0026#39;: 1, \u0026#39;*9\u0026#39;: 1, \u0026#39;1*\u0026#39;: 9, \u0026#39;2*\u0026#39;: 6, \u0026#39;**\u0026#39;: 15 }) dp = [0]*len(s) for i in range(len(s)): match_one = one.get(s[i], 0) match_two = two.get(s[i-1:i+1], 0) if i-1\u0026gt;=0 else 0 one_bit = dp[i-1]*match_one if i-1\u0026gt;=0 else match_one two_bit = dp[i-2]*match_two if i-2\u0026gt;=0 else match_two dp[i] = one_bit + two_bit return dp[-1] % (10**9+7)   ","description":"","id":15,"section":"playground","tags":["dynamic programming"],"title":"Decode Ways 2","uri":"/playground/decode-ways-2/"},{"content":"Leetcode 91\nThis is a 1-d DP. Set $dp[i]$ to be the decode ways for s[:i+1], we have:\n$$ dp[i] = dp[i-2] \\cdot M^{1}_{i} + dp[i-1] \\cdot M^{2}_{i} $$\nIn which,\n$$ \\begin{aligned} M^{1}_{i} \u0026amp;= | \\lbrace S[i] \\in A^{1} \\rbrace | \\\\ M^{2}_{i} \u0026amp;= | \\lbrace S[i-1:i+1] \\in A^{2} \\rbrace \\end{aligned} $$\n $M^{1}_{i}$ means how many ways to match the 1-character decoders $A^1$ with $S[i]$. In this problem we have either 1($S[i] \\in A^{1}$) or 0(not match, or not exists) $M^{2}_{i}$ means how many ways to match the 2-character decoders $A^2$ with $S[i-1:i+1]$. In this problem we have either 1($S[i] \\in A^{1}$) or 0(not match, or not exists)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def numDecodings(self, s: str) -\u0026gt; int: one = {str(k):1 for k in range(1, 10)} two = {str(k):1 for k in range(10, 27)} dp = [0]*len(s) for i in range(len(s)): match_one = one.get(s[i], 0) match_two = two.get(s[i-1:i+1], 0) if i-1\u0026gt;=0 else 0 one_bit = dp[i-1]*match_one if i-1\u0026gt;=0 else match_one two_bit = dp[i-2]*match_two if i-2\u0026gt;=0 else match_two dp[i] = one_bit + two_bit return dp[-1]   Notes\n Use get() to take care of cases when s[i] is not in one Take care of the corner cases when $i \u0026lt;= 2$, in which we can\u0026rsquo;t get dp values. Follow Up: Decode Ways 2 ","description":"","id":16,"section":"playground","tags":["dynamic programming"],"title":"Decode Ways","uri":"/playground/decode-ways/"},{"content":"LeetCode 84\nThe idea is somewhat similar to Longest Valid Parentheses, in which:\n Maintain a stack which stores the indices Calculate the target function each time an element pops out from the stack Take care of the corner case with -1 when we don\u0026rsquo;t have the leftmost element  Maintain a stack of indices, in which:\n All the elements in the stack follows ascending order. The elements popped out between adjacent elements remains in the stack are all taller, i.e.\n$$height[stack[j]] \u0026lt;= height[k], \\ \\forall k \\in [stack[j-1], stack[j]]$$ So for any element $j$ popped out  leftmost element is $stack[-1] + 1$ rightmost element is current index $i-1$ the width is $(i-1)-(stack[-1]+1)+1=i-stack[-1]-1$     Before height[3] enterAfter height[3] enter     0 1 2 3 4        x      x x     x x x x   x x x x x        0 1 4       o     o    x x   x x x       when 3 pops, the leftmost is 1+1=2, rightmost is 4-1=3  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def largestRectangleArea(self, heights): stack, max_area = [], 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] \u0026lt; heights[stack[-1]]: popped_idx = stack.pop() height = heights[popped_idx] left = stack[-1] + 1 if stack else 0 right = max(i-1, 0) width = right - left + 1 max_area = max(max_area, height*width) stack.append(i) return max_area   Notes:\n To ensure that left and right is valid, watch out for the corner cases when calculating. Append 0 to heights to ensure it pop out all the elements in the stack. ","description":"","id":17,"section":"playground","tags":["stack"],"title":"Largest Rectangle in Histogram","uri":"/playground/largest-rectangle-in-histogram/"},{"content":"LeetCode 85\nBorrow the idea from Largest Rectangle in Histogram, we can take the matrix as many histograms for each row level, in which we scan from top to down cumulatively to construct it:\n MatrixHistograms     1 1 0 0     1 0 1 0   0 1 1 0   0 1 1 1   1 1 1 1        1 1 0 0     2 0 1 0   0 1 2 0   0 2 3 1   1 3 4 2      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution: def largestRectangleArea(self, heights): stack, max_area = [], 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] \u0026lt; heights[stack[-1]]: popped_idx = stack.pop() height = heights[popped_idx] left = stack[-1] + 1 if stack else 0 right = max(i-1, 0) width = right - left + 1 max_area = max(max_area, height*width) stack.append(i) return max_area def maximalRectangle(self, matrix: List[List[str]]) -\u0026gt; int: n_row, n_col = len(matrix), len(matrix[0]) max_area = 0 heights = [0]*n_col for i in range(n_row): for j in range(n_col): if matrix[i][j] == \u0026#34;1\u0026#34;: heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, self.largestRectangleArea(heights)) return max_area   Notes\n Actually this is not a dp solution ","description":"","id":18,"section":"playground","tags":["dynamic programming"],"title":"Maximal Rectangle","uri":"/playground/maximal-rectangle/"},{"content":"This is about calculation Levenshtein Distance\nLeetCode 72\nLevenshtein Distance Check Levenshtein Distance for information.\nLet $\\operatorname{lev}_{a,b}(i,j)$ be the distance between the first $i$ characters of $a$ and the first $j$ characters of $b$. $i$ and $j$ are 1-based indices. We have:\n$$ \\operatorname {lev}_{a,b}(i,j) = \\begin{cases} \\max(i,j) \u0026amp; \\text{ if $min(i,j)=0$}, \\\\ \\min {\\begin{cases} \\operatorname {lev}_{a,b}(i-1,j)+1 \\\\ \\operatorname {lev}_{a,b}(i,j-1)+1 \\\\ \\operatorname {lev}_{a,b}(i-1,j-1)+1_{(a_{i} \\neq b_{j})} \\end{cases}} \u0026amp;{\\text{otherwise.}} \\end{cases} $$\nExplanation For simplification, Let dp[i][j] represent $\\operatorname{lev}_{a,b}(i,j)$.\nWe have 3 ways to reach dp[i][j]. Take a='abxy', b='abc' as an example:\n From dp[i-1][j]: Having abx -\u0026gt; abc, we need one extra del step:  abxy -\u0026gt; abcy (del y)-\u0026gt; abc   From dp[i][j-1]: Having abxy -\u0026gt; ab, we need one extra add step:  abxy -\u0026gt; ab (add c)-\u0026gt; abc   From dp[i-1][j-1]: Having abx -\u0026gt; ab, we need one extra replace step:  abxy -\u0026gt; aby (replace y to c)-\u0026gt; abc If a[i] == b[j], We could skip the replace step.    DP Solution Then we consider the corner cases. We have 0-indexing system, in which situation we can achive -1 indexing.\n If i = -1 or j = -1, then we need to convert an empty string to another non-empty string, by inserting, the cost is the length of the non-empty string, in the above example, when i=-1 and j=1, we convert '' to ab, the cost is 2, dp[i][j] = j+1 = 2 If i = -1 and j = -1, we convert an empty string to another empty string, dp[-1][-1] = 0  There are two strategies to take care of these situations.\n Using a custom indexing system to take care of index overflow. We could use the dp as it was. Taking care of the indexing on the fly. This is less readable than method 1, personally not recommended. Add an extra row and column, start from (1,1) instead of (0,0), which has pros and cons compared to method 1.  We use method 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution: def minDistance(self, word1: str, word2: str) -\u0026gt; int: m, n = len(word1), len(word2) if m == 0 and n == 0: return 0 elif m == 0: return n elif n == 0: return m dp = [[float(\u0026#34;inf\u0026#34;)]*n for _ in range(m)] def index(i, j): if i == -1 and j == -1: return 0 elif i == -1: return j+1 elif j == -1: return i+1 else: return dp[i][j] for i in range(m): for j in range(n): cost = int(word1[i]!=word2[j]) dp[i][j] = min(index(i-1,j)+1, index(i,j-1)+1, index(i-1,j-1)+cost) return dp[-1][-1]   This method has problem to deal with empty string, in which we generate the result in index() on the fly, which is out of the dp table itself. Try method 3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def minDistance(self, word1: str, word2: str) -\u0026gt; int: m, n = len(word1), len(word2) dp = [[float(\u0026#34;inf\u0026#34;)]*(n+1) for _ in range(m+1)] dp[0][0] = 0 for i in range(1, n+1): dp[0][i] = i for j in range(1, m+1): dp[j][0] = j for i in range(1, m+1): for j in range(1, n+1): cost = int(word1[i-1]!=word2[j-1]) dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost) return dp[-1][-1]   Notes:\n word index changes from i, j to i-1, j-1 in method 3. We may optimize the space of the code to use only two vectors, or even one. ","description":"","id":19,"section":"playground","tags":["dynamic programming"],"title":"Edit Distance","uri":"/playground/edit-distance/"},{"content":"LeetCode 64\nThis is pretty much like unique paths.\nLet $dp[i][j]$ to be the total unique paths to $board[i][j]$, the state transision is easy to find:\n$$ dp[i][j] = \\min \\lbrace dp[i-1][j], dp[i][j-1] \\rbrace + grid[i][j] $$\nAs in the unique paths, we define a custom indexing function to take care of corner cases.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: def minPathSum(self, grid: List[List[int]]) -\u0026gt; int: n_row, n_col = len(grid), len(grid[0]) min_sum = float(\u0026#34;inf\u0026#34;) def index(i, j): if i in range(n_row) and j in range(n_col): return dp[i][j] else: return float(\u0026#34;inf\u0026#34;) dp = [[float(\u0026#34;inf\u0026#34;)]*n_col for _ in range(n_row)] dp[0][0] = grid[0][0] for i in range(n_row): for j in range(n_col): if i == 0 and j == 0: continue dp[i][j] = min(index(i-1, j), index(i, j-1)) + grid[i][j] return dp[n_row-1][n_col-1]   ","description":"","id":20,"section":"playground","tags":["dynamic programming"],"title":"Minimal Path Sum","uri":"/playground/minimal-path-sum/"},{"content":"Walk over all grids without duplicate, with obstacles\nDescription See LeetCode 980\nDFS Backtracking Solution Unlike the DP solutions to Unique path 1 and 2, we cannot reuse calculated paths cuz we can walk forth and back into the same arange (i, j). And the start and end position varies. Using a DFS.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution: def uniquePathsIII(self, grid: List[List[int]]) -\u0026gt; int: n_row, n_col = len(grid), len(grid[0]) self.count, empty = 0, 1 # find start and end, count empty grids for i in range(n_row): for j in range(n_col): if grid[i][j] == 0: empty += 1 if grid[i][j] == 1: start = [i, j] if grid[i][j] == 2: end = [i, j] def search(i, j, empty): if i in range(n_row) and j in range(n_col) and grid[i][j] \u0026gt;= 0: if ([i, j] == end) and (empty == 0): self.count += 1 return grid[i][j] = -2 search(i-1, j, empty-1) search(i+1, j, empty-1) search(i, j-1, empty-1) search(i, j+1, empty-1) grid[i][j] = 0 search(start[0], start[1], empty) return self.count   Note\n We initialize empty with 1, cuz the start of the search counts. Search in a grid is frequently used, we need to restore the element after search. The search function could be memorized to accelerate. ","description":"","id":21,"section":"playground","tags":["backtracking","dfs"],"title":"Unique Paths 3","uri":"/playground/unique-paths-3/"},{"content":"Count all paths from a to b, with obstacles.\nDescription See LeetCode 63\nDynamic Programming Solution Let $dp[i][j]$ to be the total unique paths to $board[i][j]$, the state transision is easy to find:\n dp[i-1][j] ^ | dp[i][j-1]\u0026lt;--dp[i][j] $$ dp[i][j] = \\begin{cases} dp[i-1][j] + dp[i][j-1], \u0026amp; \\text{$board[i][j] = 0$} \\\\ 0, \u0026amp; \\text{$board[i][j] = 1$} \\end{cases} $$\nWatch out for the initial condition: we con\u0026rsquo;t initialize all values to 1 on the first row and first col.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u0026gt; int: n_row, n_col = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n_col for _ in range(n_row)] if obstacleGrid[0][0] != 1: dp[0][0] = 1 def index(i, j): if i in range(n_row) and j in range(n_col): return dp[i][j] else: return 0 for i in range(n_row): for j in range(n_col): if i == 0 and j == 0: continue if obstacleGrid[i][j] == 0: dp[i][j] = index(i-1, j) + index(i, j-1) return dp[n_row-1][n_col-1]   ","description":"","id":22,"section":"playground","tags":["dynamic programming"],"title":"Unique Paths 2","uri":"/playground/unique-paths-2/"},{"content":"Count all paths from a to b\nDescription See LeetCode 62\nDynamic Programming Solution Let $dp[i][j]$ to be the total unique paths to $board[i][j]$, the state transision is easy to find:\n dp[i-1][j] ^ | dp[i][j-1]\u0026lt;--dp[i][j] $$ dp[i][j] = dp[i-1][j] + dp[i][j-1] $$\n Define a custom indexing function to take care of corner cases. The filling order is described as follow for $row=3, col=4$:     0 1 2 3     4 5 6 7   8 9 10 11    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[0]*n for _ in range(m)] dp[0][0] = 1 def index(i, j): if i in range(m) and j in range(n): return dp[i][j] else: return 0 for i in range(m): for j in range(n): if i == 0 and j == 0: continue dp[i][j] = index(i-1, j) + index(i, j-1) return dp[m-1][n-1]   ","description":"","id":23,"section":"playground","tags":["dynamic programming"],"title":"Unique Paths","uri":"/playground/unique-paths/"},{"content":"Description Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nExample:\nInput: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.\nFollow up:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nDynamic Programming Solution Let $dp[i]$ to be the maximum subarray value that ends at $nums[i]$, which is all the possible subarray sum which ends at $i$, i.e.\n$$ \\begin{aligned} dp[i] \u0026amp;= \\max_{j \\in [0, i] } \\left\\lbrace \\sum\\limits_{k=j}^{i} nums[k] \\right\\rbrace \\\\ \u0026amp;= \\max_{j \\in [0, i] } \\left\\lbrace \\sum\\limits_{k=j}^{i-1} nums[k],0 \\right\\rbrace + nums[i] \\\\ \u0026amp;= \\max \\left\\lbrace dp[i-1], 0 \\right\\rbrace + nums[i] \\end{aligned} $$\n1 2 3 4 5 6 7  class Solution: def maxSubArray(self, nums: List[int]) -\u0026gt; int: dp, max_sum = [0]*len(nums), -float(\u0026#34;inf\u0026#34;) for i in range(len(nums)): dp[i] = (max(dp[i-1], 0) if i-1\u0026gt;=0 else 0) + nums[i] max_sum = max(max_sum, dp[i]) return max_sum   Notes\n When calculating dp[i-1], watch out for the corner case. Generate max_sum in each iter on the fly. ","description":"","id":24,"section":"playground","tags":["dynamic programming"],"title":"Maximum Subarray","uri":"/playground/maximum-subarray/"},{"content":"Description Given a string containing just the characters \u0026lsquo;(', \u0026lsquo;)', \u0026lsquo;{', \u0026lsquo;}', \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]', determine if the input string is valid.\nAn input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid.\nStack Solution Keep a stack\n When a ( arrives, push it into the stack When a ) arrives, compare it with the top of stack, if it forms a pair, pop it, else push it.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution: def isValid(self, s: str) -\u0026gt; bool: left_set = {\u0026#39;(\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;[\u0026#39;} right_set = {\u0026#39;)\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;]\u0026#39;} get_pair = { \u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, \u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, \u0026#39;]\u0026#39;: \u0026#39;[\u0026#39; } stack = [] for p in s: if p in left_set: stack.append(p) else: if stack and stack[-1] == get_pair[p]: stack.pop() else: stack.append(p) return len(stack) == 0   Notes\n We use a dict to check if the pair is valid. Watch out for corner case before indexig. Follow up ","description":"","id":25,"section":"playground","tags":["stack"],"title":"Valid Parentheses","uri":"/playground/valid-parentheses/"},{"content":"Description Given a string containing just the characters \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)', find the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: \u0026quot;(()\u0026quot; Output: 2 Explanation: The longest valid parentheses substring is \u0026quot;()\u0026quot; Example 2:\nInput: \u0026quot;)()())\u0026quot; Output: 4 Explanation: The longest valid parentheses substring is \u0026quot;()()\u0026quot; Dynamic Programming Solution Let $dp[i]$ to be the length of the longest valid parentheses which ends at $i$'th position.\n $s[i]$ must be ) to have a valid parentheses, else $dp[i] = 0$\n Depends on s[i-1], we have 2 situations:\n $s[i-1] = ($     \u0026hellip; i-2 i-1 i     \u0026hellip; . ( )    dp[i-2] 0 dp[i]    dp[i] = dp[i-2] + 2 $s[i-1] = )$\nwe have 2 situations, only needs to consider $s[i-dp[i-1]-1] = ($     i-dp[i-1]-2 i-dp[i-1]-1 i-dp[i-1] \u0026hellip; i-1 i     ? ( ( \u0026hellip; ) )   dp[i-dp[i-1]-2] 0 0 \u0026hellip; dp[i-1] dp[i]    dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2 Combining all the situations above, we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def longestValidParentheses(self, s: str) -\u0026gt; int: n = len(s) dp = [0]*n _max = 0 for i in range(n): if s[i] == \u0026#39;)\u0026#39; and (i-1\u0026gt;=0): if s[i-1] == \u0026#39;(\u0026#39;: dp[i] = (dp[i-2] if (i-2\u0026gt;=0) else 0) + 2 _max = max(_max, dp[i]) else: if (i-dp[i-1]-1\u0026gt;=0) and s[i-dp[i-1]-1] == \u0026#39;(\u0026#39;: dp[i] = dp[i-1] + 2 + (dp[i-dp[i-1]-2] if (i-dp[i-1]-2\u0026gt;=0) else 0) _max = max(_max, dp[i]) return _max   Though the DP solution is not quite intuitive for me.\nStack Solution Maintain a stack, which borrows the idea from Valid Parentheses\n When a ( arrives, push it into the stack When a ) arrives, compare it with the top of stack, if it forms a pair, pop it, else push it. After the whole process, the items left in the stack are those not having valid pairs. On the other side, other elements are valid pairs. We just need to find longest space between those elements in the stack. So we push index of the elements, instead of the element itself.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def longestValidParentheses(self, s: str) -\u0026gt; int: stack: List[int] = [] max_len: int = 0 for i in range(len(s)): if s[i] == \u0026#39;(\u0026#39;: stack.append(i) elif s[i] == \u0026#39;)\u0026#39;: if stack and s[stack[-1]] == \u0026#39;(\u0026#39;: stack.pop() last_not_paired = stack[-1] if stack else -1 max_len = max(max_len, i-last_not_paired) else: stack.append(i) return max_len   Notes\n We generate the max length on the fly. Each time a pair generated, we calculate space between current element and last element remains in the stack, which is the last index that has not been paired yet, which is the current length of the generated valid substring. Watch out for corner case: if the stack is empty, we cannot find last element that has not been pairs, just put -1 to it shoud be fine. ","description":"","id":26,"section":"playground","tags":["dynamic programming","stack"],"title":"Longest Valid Parentheses","uri":"/playground/longest-valid-parentheses/"},{"content":"Description Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1:\nInput: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer. Example 2:\nInput: \u0026quot;cbbd\u0026quot; Output: \u0026quot;bb\u0026quot; Dynamic Programming Solution Let dp[i][j] indicates that s[i:j+1] is a palindromic sequence, we have\n$$ dp[i][j] = \\begin{cases} True, \u0026amp; \\text{$i$ = $j$} \\\\ s[i] = s[j], \u0026amp; \\text{$j$ - $i$ = 1} \\\\ (s[i] = s[j]) \\ \\text{and} \\ dp[i+1][j-1], \u0026amp; \\text{$j$ - $i$ \u0026gt; 1} \\end{cases} $$\n dp[i][j] / dp[i+1][j-1] Filling order is as described below:\n   i\\j b a b a d     b 0 1 3 6 10   a  2 4 7 11   b   5 8 12   a    9 13   d     14    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: max_substr = \u0026#34;\u0026#34; dp = [[False]*len(s) for _ in range(len(s))] for j in range(len(s)): for i in range(j+1): if i == j: dp[i][j] = True elif j-i == 1: dp[i][j] = s[i] == s[j] else: dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1] if dp[i][j] and j-i+1 \u0026gt; len(max_substr): max_substr = s[i:j+1] return max_substr   Palindrome Ad-hoc Solution Set $i$ to be the center of palindrome sunstring, $j$ to be the radius, we can expand from center to side to valid the substring:\n Odd length substring:  Expand from $(i, i)$, in which $j=0$, $L=i-j, R=i+j$, length of the substring is $2j+1$, $r_{max} = i$   Even length substring:  Expand from $(i-1, i)$, in which $j=0$, $L=i-1-j, R=i+j$, length of the substring is $2j+2$, $r_{max} = i$       i-j   i-1 i i+1   i+r      1 2 3 4 5 4 3 2 1        i-1 i       1 2 3 4 5 5 4 3 2 1    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: n, max_len, max_str = len(s), 0, \u0026#34;\u0026#34; for i in range(n): for j in range(i+1): l, r = i-j, i+j if l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: if max_len \u0026lt; 2*j+1: max_len = 2*j+1 max_str = s[l:r+1] else: break for j in range(i+1): l, r = i-1-j, i+j if l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: if max_len \u0026lt; 2*j+2: max_len = 2*j+2 max_str = s[l:r+1] else: break return max_str   Manacher Algorithm Check wiki~ it is O(n)\n","description":"","id":27,"section":"playground","tags":["dynamic programming"],"title":"Longest Palindromic Substring","uri":"/playground/longest-palindromic-substring/"},{"content":"Description Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for \u0026lsquo;?\u0026rsquo; and \u0026lsquo;*'.\n \u0026lsquo;?\u0026rsquo; Matches any single character. \u0026lsquo;*\u0026rsquo; Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).  Note:\n s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1:\nInput: s = \u0026quot;aa\u0026quot; p = \u0026quot;a\u0026quot; Output: false Explanation: \u0026quot;a\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;. Example 2: Input: s = \u0026quot;aa\u0026quot; p = \u0026quot;*\u0026quot; Output: true Explanation: '*' matches any sequence. Backtracking Solution This is an easier version of Regular Expression Matching, since we don\u0026rsquo;t need to check character matching when we get a wildcard. The logic is:\nWe define search(si, pi) as the search function, which means if s[si:] is matched by p[pi:].\nFirst check if it is a wildcard: pi \u0026lt; len(p) and p[pi] == \u0026quot;*\u0026quot;\n If it is, match this or not: search(si+1, pi) or search(si, pi+1) If not, just match current character: si \u0026lt; len(s) and p[pi] in {s[si], \u0026quot;?\u0026quot;}  Search next level: search(si+1, pi+1)    1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def isMatch(self, s: str, p: str) -\u0026gt; bool: def search(si: int, pi: int) -\u0026gt; bool: if pi == len(p): return si == len(s) wildcard: bool = pi \u0026lt; len(p) and p[pi] == \u0026#34;*\u0026#34; if wildcard: return (si \u0026lt; len(s) and search(si+1, pi)) or search(si, pi+1) else: match: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;?\u0026#34;} return match and search(si+1, pi+1) return search(0, 0)   Again, it could be optimized through cache.\nDynamic Programming First we can construct state transision from the backtracking method. Jut let search(si, pi) to be dp[si][pi]\n1 2 3 4  dp[si][pi] \u0026lt;--dp[si][pi+1] ^ \\ | \\ dp[si+1][pi] dp[si+1][pi+1]    We have a (len(s) + 1, len(p) +1) matrix, the iteration order is described below. Starting from dp[len(s)][len(p)-1], we need to get dp[0][0] Set dp[len(s)][len(p)] = True, which indicates our backtracking terminal condition(find a match).     s\\p * a * b      a end    F   b     F   c     F   e     F   b     F       start T    1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution: def isMatch(self, s: str, p: str) -\u0026gt; bool: dp: List[List[bool]] = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[len(s)][len(p)] = True for si in range(len(s), -1, -1): for pi in range(len(p)-1, -1, -1): wildcard: bool = pi \u0026lt; len(p) and p[pi] == \u0026#34;*\u0026#34; if wildcard: dp[si][pi] = (si \u0026lt; len(s) and dp[si+1][pi]) or dp[si][pi+1] else: match: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;?\u0026#34;} dp[si][pi] = match and dp[si+1][pi+1] return dp[0][0]   ","description":"","id":28,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Wildcard Matching","uri":"/playground/wildcard-matching/"},{"content":"We can easily optimize a recursion by using a cache, which loads calculated function calls during the recursion process.\ncode usage  1 2 3 4 5 6 7 8 9 10 11  from functools import wraps def memo(func): cache = dict() @wraps(func) def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap     Some conditional branches could be merged by and operator.\n1 2 3 4 5 6  @memo def fib(n: int) -\u0026gt; int: if n in {0, 1}: return 1 else: return fib(n-1) + fib(n-1)       'use strict'; var containerId = JSON.parse(\"\\\"c25bbdc999ed7b79\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; } ","description":"","id":29,"section":"playground","tags":null,"title":"Optimize Recursion","uri":"/playground/optimize-recursion/"},{"content":"Description Given an input string (s) and a pattern (p), implement regular expression matching with support for \u0026lsquo;.\u0026rsquo; and \u0026lsquo;*'.\n'.' Matches any single character. '*' Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note:\n s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example :\nInput: s = \u0026quot;aab\u0026quot; p = \u0026quot;a*b\u0026quot; Output: true Explanation: \u0026quot;a*\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;. Backtracking Solution We define search(si, pi) as the search function, which means if s[si:] is matched by p[pi:].\nFirst we need to check if p[pi] is a wildcard: p[pi+1] == \u0026quot;*\u0026quot;, and don\u0026rsquo;t forget the corner case: pi+1 \u0026lt; len(p)\n Not wildcard: Just check if s[si] and p[pi] is same character: si \u0026lt; len(s) and s[si] == p[pi]  If it is, search next level: search(si+1, pi+1) If not, just return False, search ends here.   Wildcard: Same as step 1, check if it\u0026rsquo;s the same character:  If it is, that\u0026rsquo;s a valid wildcard match. But we could still choose to match or skip this wildcard: search(si+1, pi) or search(si, pi+2) If not, the only choice is to skip this wildcard: search(si, pi+2)    straight concise  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def isMatch(self, s: str, p: str) -\u0026gt; bool: def search(si: int, pi: int) -\u0026gt; bool: if pi == len(p): return si == len(s) wildcard: bool = pi+1 \u0026lt; len(p) and p[pi+1] == \u0026#34;*\u0026#34; match: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;.\u0026#34;} if wildcard: if match: return search(si+1, pi) or search(si, pi+2) else: return search(si, pi+2) else: if march: search(si+1, pi+1) else: return False return search(0, 0)     Some conditional branches could be merged by and operator.\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution: def isMatch(self, s: str, p: str) -\u0026gt; bool: def search(si: int, pi: int) -\u0026gt; bool: if pi == len(p): return si == len(s) wildcard: bool = pi+1 \u0026lt; len(p) and p[pi+1] == \u0026#34;*\u0026#34; match: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;.\u0026#34;} if wildcard: return (match and search(si+1, pi)) or search(si, pi+2) else: return match and search(si+1, pi+1) return search(0, 0)       'use strict'; var containerId = JSON.parse(\"\\\"a06db6b3247b3890\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }   The code could be easily optimized using a cache to avoid duplicate calculation. See Optimize Recursion. Always pay attention to corner cases in recursion. Below is an example for matching aab and c*a*ab, with the dicision tree of the backtracking search path.  graph TD; subgraph DecisionTree DROOT(Wildcard?)--\u0026gt;|Y|DL(char?); DL--\u0026gt;|Y|DLL(match?); DLL--\u0026gt;|Y|DLLL(si+1, pi); DLL--\u0026gt;|N|DLLR(si, pi+2); DL--\u0026gt;|N|DLR(si, pi+2); DROOT--\u0026gt;|N|DR(char?); DR--\u0026gt;|Y|DRL(si+1, pi+1); DR--\u0026gt;|N|DRR(False); end subgraph MatchExample ROOT(aab,c*a*ab)--\u0026gt;|skip c*|L(aab, a*ab); L--\u0026gt;|match a*|LL(ab,a*ab) L--\u0026gt;|skip a*|LR(aab,ab); LL--\u0026gt;|match a*|LLL(b,a*ab); LLL--\u0026gt;|skip a*|LLLL(b,ab); LL--\u0026gt;|skip a*|LLR(ab,ab); LR--\u0026gt;|match a|LRL(ab,b); LLR--\u0026gt;|match a|LLRL(b,b); LLRL--\u0026gt;|match b|LLRLL([END]); end Dyamic Programming First we can construct state transision from the backtracking method. Jut let search(si, pi) to be dp[si][pi]\n1 2 3 4  dp[si][pi] \u0026lt;--------------- dp[si][pi+2] ^ \\ | \\ dp[si+1][pi] dp[si+1][pi+1]    We have a (len(s) + 1, len(p) +1) matrix, the iteration order is described below. Starting from dp[len(s)][len(p)-1], we need to get dp[0][0] Set dp[len(s)][len(p)] = True, which indicates our backtracking terminal condition(find a match).     s\\p c * a * a b      a end      F   a       F   b       F         start T    The core logic is pretty straightforward like backtracking solution:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def isMatch(self, s: str, p: str) -\u0026gt; bool: dp: List[List[bool]] = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[len(s)][len(p)] = True for si in range(len(s), -1, -1): for pi in range(len(p)-1, -1, -1): wildcard: bool = pi+1 \u0026lt; len(p) and p[pi+1] == \u0026#34;*\u0026#34; match: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;.\u0026#34;} if wildcard: dp[si][pi] = (match and dp[si+1][pi]) or dp[si][pi+2] else: dp[si][pi] = match and dp[si+1][pi+1] return dp[0][0]   Notes:\n This is similar to Distinct Subsequences ","description":"","id":30,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Regular Expression Matching","uri":"/playground/regular-expression-matching/"},{"content":"MathJax  A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.\n When \\(a \\ne 0\\), there are two solutions to \\((ax^2 + bx + c = 0)\\) and they are \\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\]\nChartJS  Simple yet flexible JavaScript charting for designers \u0026amp; developers\n { \u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [{ \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8] }] } } { \u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [ { \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot; }, { \u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;, \u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot; } ] } } FLowChart  flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.\n st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank] e=\u0026gt;end: End|future:\u0026gt;http://www.google.com op1=\u0026gt;operation: My Operation|past op2=\u0026gt;operation: Stuff|current sub1=\u0026gt;subroutine: My Subroutine|invalid cond=\u0026gt;condition: Yes or No?|approved:\u0026gt;http://www.google.com c2=\u0026gt;condition: Good idea|rejected io=\u0026gt;inputoutput: catch something...|future st-\u0026gt;op1(right)-\u0026gt;cond cond(yes, right)-\u0026gt;c2 cond(no)-\u0026gt;sub1(left)-\u0026gt;op1 c2(yes)-\u0026gt;io-\u0026gt;e c2(no)-\u0026gt;op2-\u0026gt;e JS Sequence Diagram support  Generates UML sequence diagrams from simple text\n Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! Title: Here is a title A-\u0026gt;B: Normal line B--\u0026gt;C: Dashed line C-\u0026gt;\u0026gt;D: Open arrow D--\u0026gt;\u0026gt;A: Dashed open arrow KaTex  KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.\n The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $ Inline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nMermaid  Generate diagrams, charts, graphs or flows from markdown-like text via javascript.\n graph TD; A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; sequenceDiagram participant Alice participant Bob Alice-\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! graph TD A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u0026lt;\u0026lt;service\u0026gt;\u0026gt; int id size() } stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] pie \u0026quot;Dogs\u0026quot; : 386 \u0026quot;Cats\u0026quot; : 85 \u0026quot;Rats\u0026quot; : 15 Wavedrom support  WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.\n { \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]}, {\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;}, {}, {\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;} ]} ","description":"Sample article showcasing test features like charts and latex equations.","id":31,"section":"blogs","tags":["markdown"],"title":"Library Support Guidance","uri":"/blogs/lib-guidance/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nEmoji Support Emoji can be enabled in a Hugo project in a number of ways.\n The emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }   Math TypeSetting We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)  Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\n In this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026quot;math.html\u0026quot; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nRich Content Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nShort Codes Markdownify box This is boxmd shortcode Simple box This is **box** shortcode  Code tabs Make it easy to switch between different code\njava javascript  1  System.out.println(\u0026#39;Hello World!\u0026#39;);     1  console.log(\u0026#39;Hello World!\u0026#39;);       'use strict'; var containerId = JSON.parse(\"\\\"d96f892eb0443615\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  Tabs for general purpose Windows MacOS Ubuntu  Windows section 1  console.log(\u0026#39;Hello World!\u0026#39;);   ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n MacOS section Hello world!  Ubuntu section Great!    'use strict'; var containerId = JSON.parse(\"\\\"7f7c6142046c0503\\\"\"); var containerElem = document.getElementById(containerId); var tabLinks = null; var tabContents = null; var ids = []; if (containerElem) { tabLinks = containerElem.querySelectorAll('.tab__link'); tabContents = containerElem.querySelectorAll('.tab__content'); } for (var i = 0; i 0) { tabContents[0].style.display = 'block'; }  Expand   Expand me  Title contents     Expand me2  Title2 contents2   Alert Colored box\nthis is a text this is a text this is a text this is a text Notice success text  info text  warning text  error text  Code Syntax Highlighting Verify the following code blocks render as code blocks and highlight properly.\nDiff 1 2 3 4 5 6 7 8 9 10  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; --- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39; *************** *** 1 **** ! This is a line. --- 1 --- ! This is a replacement line. It is important to spell -removed line +new line   Makefile 1 2 3 4 5  CC=gcc CFLAGS=-I. hellomake: hellomake.o hellofunc.o $(CC) -o hellomake hellomake.o hellofunc.o -I.   JSON 1 2 3  {\u0026#34;employees\u0026#34;:[ {\u0026#34;firstName\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Doe\u0026#34;}, ]}   Markdown 1 2 3  **bold** *italics* [link](www.example.com)   JavaScript 1  document.write(\u0026#39;Hello, world!\u0026#39;);   CSS 1 2 3  body { background-color: red; }   Objective C 1 2 3 4 5 6  #import \u0026lt;stdio.h\u0026gt;  int main (void) { printf (\u0026#34;Hello world!\\n\u0026#34;); }   Python 1  print \u0026#34;Hello, world!\u0026#34;   XML 1 2 3 4 5  \u0026lt;employees\u0026gt; \u0026lt;employee\u0026gt; \u0026lt;firstName\u0026gt;John\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;Doe\u0026lt;/lastName\u0026gt; \u0026lt;/employee\u0026gt; \u0026lt;/employees\u0026gt;   Perl 1  print \u0026#34;Hello, World!\\n\u0026#34;;   Bash 1  echo \u0026#34;Hello World\u0026#34;   PHP 1  \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;   CoffeeScript 1  console.log(“Hello world!”);   C# 1 2 3 4 5 6 7 8  using System; class Program { public static void Main(string[] args) { Console.WriteLine(\u0026#34;Hello, world!\u0026#34;); } }   C++ 1 2 3 4 5 6 7  #include \u0026lt;iostream.h\u0026gt; main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;; return 0; }   SQL 1 2  SELECT column_name,column_name FROM table_name;   Go 1 2 3 4 5  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, 世界\u0026#34;) }   Ruby 1  puts \u0026#34;Hello, world!\u0026#34;   Java 1 2 3 4 5 6 7 8 9 10 11 12  import javax.swing.JFrame; //Importing class JFrame import javax.swing.JLabel; //Importing class JLabel public class HelloWorld { public static void main(String[] args) { JFrame frame = new JFrame(); //Creating frame  frame.setTitle(\u0026#34;Hi!\u0026#34;); //Setting title frame  frame.add(new JLabel(\u0026#34;Hello, world!\u0026#34;));//Adding text to frame  frame.pack(); //Setting size to smallest  frame.setLocationRelativeTo(null); //Centering frame  frame.setVisible(true); //Showing frame  } }   Latex Equation 1  \\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x).   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {x, y} as p from \u0026#39;point\u0026#39;; const ANSWER = 42; class Car extends Vehicle { constructor(speed, cost) { super(speed); var c = Symbol(\u0026#39;cost\u0026#39;); this[c] = cost; this.intro = `This is a car runs at ${speed}.`; } } for (let num of [1, 2, 3]) { console.log(num + 0b111110111); } function $initHighlight(block, flags) { try { if (block.className.search(/\\bno\\-highlight\\b/) != -1) return processBlock(block.function, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;; } catch (e) { /* handle exception */ var e4x = \u0026lt;div\u0026gt;Example \u0026lt;p\u0026gt;1234\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;; } for (var i = 0 / 2; i \u0026lt; classes.length; i++) { // \u0026#34;0 / 2\u0026#34; should not be parsed as regexp  if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } console.log(Array.every(classes, Boolean)); } export $initHighlight;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello world\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;index.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;vendor/prism.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;examples.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /********************************************************* * General */ pre[class*=\u0026#34;language-\u0026#34;], code { color: #5c6e74; font-size: 13px; text-shadow: none; font-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace; direction: ltr; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; line-height: 1.5; tab-size: 4; hyphens: none; } pre[class*=\u0026#34;language-\u0026#34;]::selection, code::selection { text-shadow: none; background: #b3d4fc; } @media print { pre[class*=\u0026#34;language-\u0026#34;], code { text-shadow: none; } } pre[class*=\u0026#34;language-\u0026#34;] { padding: 1em; margin: .5em 0; overflow: auto; background: #f8f5ec; } :not(pre) \u0026gt; code { padding: .1em .3em; border-radius: .3em; color: #db4c69; background: #f9f2f4; }    The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":32,"section":"blogs","tags":["markdown"],"title":"Markdown Basic Syntax","uri":"/blogs/basic/"},{"content":"\n","description":"About xxuan.me backup site xxuan.cc","id":33,"section":"","tags":null,"title":"About","uri":"/about/"}]