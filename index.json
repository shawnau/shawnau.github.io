[{"content":" Time to mix drinks and change lives\n VA-11 HALL-A VA-11 HALL-A是2016年6月21日登陆Steam的一款单人AVG游戏, 在游戏里你需要做的事情很少. 简单来说, 就是调酒, 听客人吐槽以及吐槽客人, 捎带每天晚上去购物满足主角Jill的消费欲, 以及赚够足够的房租不至于流落街头.\n因为一些游戏之内以及之外的故事, 它意外地获得了非常好的评价, 以及很多meme. 在此就不展开了, 有兴趣可以自己搜搜(毕竟本文也不是来推销游戏的) 单纯从游戏内容来看, 8bit风格十足的美术和音乐, 鲜活的人物刻画, 以及充斥着整个游戏的(语文不好不知道如何形容, 4chan味?)构造出一个十分有沉浸感的世界.\n当然, 既然是赛博朋克, 反乌托邦那套世界观拿来就用了. 巧在现代互联网社区的阴暗角落(没错,又是4chan)里充斥着的元素和这样的世界观异常相配, 产生了奇妙的化学反应, 这样虚拟世界/网络世界/现实的模糊也是沉浸感的来源.\nThe cyberpunk world was born for criticism, which is far from even a fine world. There\u0026rsquo;s bitter behind the guys created the game, and it\u0026rsquo;s not their fault.\nThe idea of cyberpunk is so famous. I\u0026rsquo;m guessing some big names would feel sting in their backs while other poor guys creating, contributing, and being a part of this world.\n\r\r一些可以跳过的无关私货\r\r之所以对这个游戏有如此深刻的印象, 还是要回到现实, 看看当时发生了啥. 好在我有玩完游戏写review的习惯, 翻到大概是在2018年7月15日在steam写的, 根据时间来回忆一下\u0026quot;操蛋的现实\u0026quot;指的都是啥.\n1 2 3 4 5 6 7 8 9 10 11  很高兴能暂时脱离这操蛋的现实,在vallhala里呆一会, 体验他们更操蛋的生活. 这很赛博朋克.\r希望有一家这样的酒吧可以去, 虽然我不能喝酒, 但可以Sugar Rush嘛\r最后, 太真实了, 买买买还是很容易导致交不起房租的!\r下面是私货\r1. Rad Shiba(有提到是高智商写程序的犬类) -\u0026gt; Ein\r2. Jamie曾经提到的传奇杀手外号Black Dog -\u0026gt; Jet的外号\r3. Alma -\u0026gt; Ed(肤色很像, 都是黑客, 身材嘛...who knows?)\r4. 有一款酒名为Crevice Spike\r5. 月球爆炸了!(cb世界观)\r作为cb粉真的被爽到了.\r  2018年7月, 研究生二年级暑假, 我刚好结束为期1年的实习, 离开上海回家, 准备秋招踏上社畜之路. 那个时候完全没有职场经验, 属于走进面试间两腿就打颤的水平, 很方. (搞笑的是后来面多了才知道根本没有面试间, 成百上千人挤在一起 搬个小桌子和你面对面都很奢侈了)\n不过刚到家屁股还没坐热, 我爹晕倒在了家里, 感觉这种关头人会觉得事情一下子就全都来的很快: 打120, 进急诊室, 医生就让我签责任书, 使用溶栓药. 因为这玩意会清除血栓, 但也有一定概率造成脑出血, 所以我要为我的决定负责. 面对的是自己的亲爹, 这种感觉难以描述. 打完效果未卜转到南京省院, 在医院打地铺通宵等医生消息. 好在之后恢复得很好, 甚至都没有留下什么后遗症, 并且也没有再复发过. 对坚持锻炼的我爹报以崇高的敬意.\n后来我在准备面试的闲暇时间打完了这游戏, 经历了这一切求职时心态反而很好, 感觉自己也成长了一些, 不过代价还是太大了, 不如不要. 游戏如果足够好, 就能让人暂时从现实脱身, 躲在安全的壳儿里神游一会(其实好电影也一样). 四处奔波面试的我大概是很珍惜这段时间了.\n想起自己16年本科毕业之后不想继续读基础学科了, 也逃避就业, 一个人在南大和园租了个毛坯房, 闷头准备了一年考研, 当时印象最深的是看完了7部jojo, 玩了几遍Undertale. 白天见的人太少了有点恍惚, 晚上就去GTA5里上街瞎逛, 感觉都是很相似的经历.\n\r Ben\u0026rsquo;s Secret 去年我在b站发现一位调酒师UP神秘金针菇先生发了游戏里酒的复刻(当然不能真按游戏里的配方来, 需要要调酒师自己去按照酒的属性创作, 所以不会调酒就别瞎折腾了), 发现酒吧在南京, 就收藏了希望哪天有机会去体验一下. 所以, 2021年6月的最后一个周末, 冒着夜里的小雨, 我终于有机会前去拜访一下. 这还是我第一次去酒吧\u0026hellip;本人基本上不喝酒, 以前在实验室闻了太多乙醇, 和巴普洛夫的狗子一样训练出了ptsd. 哈哈\n酒吧大门\r内景\r漫画\r\r酒吧门口的招牌. 其实藏得很深, 门口是烤肉店. 很有设计感的招牌.\r\r排排坐就满啦. 有全套eva和王牌酒保漫画可看, 当然也有调酒文化相关的书籍供阅览.\r\r         贞本义行老师的EVA. 漫画作者和我一样是个丽党, 我喜欢这个版本的结局 王牌酒保是调酒师入行的引子呢. 不过依他所言, 现实要是和漫画里一样, 酒吧就要关门咯. 所以说漫画就是漫画, 啊哈哈.    \r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"2d470dd7c69fca97\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r 幸运地找到了UP主, 表明了是他的粉丝!(其实是假粉, 视频都没看完, 后来果然暴露了, hiahia), 点了两杯女性化的酒 - Sugar Rush, Fluffy Dream以及一杯黄油啤酒 (拍照过于激动还打翻了一杯, 罪过罪过)\nSugar-Rush\rFluffy-Dream\rButterBeer\r\r经典的Sugar Rush, 不含酒精, 杯子真的很迷你, 有那种女性化的可爱感觉\r\rFluffy Dream, 微酸, 很柔和的口感, 清爽\r\r黄油啤酒, 肉桂和麦芽香气让这款酒特别上头\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"5ccfd324dc66ad56\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r\n其实还有好几件意外惊喜没能多拍点记录下来(只顾吃喝了), 恰逢酒吧一位客人过生日, 我还收到了一份马卡龙和蛋糕, 希望过生日的小伙也能收到我的祝福哈. 以及给老板拍了一张Portra400, 可惜酒吧有点儿暗, 外加当时机器还没完全修好, 我自觉拍得不够完美, 希望神秘金针菇先生不介意就好哈. 顺便也给Sugar Rush拍了一张.\nSugar-Rush靓照\r调酒师靓照\r\r虽然有点暗但是很有氛围感\r\r调酒师很亲切, 有可爱的娃娃脸, 还替我们科普了很多有趣的调酒知识\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"abd43e471f043960\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r 如果有机会, 下次一定带灯和脚架来拍. 感谢茜茜, 感谢调酒师先生以及酒吧里的客人们, 让我有了这次奇妙而难忘的经历.\n\r尾声悄悄话\r2021年了, 我的经历还要以图文这朴素的方式记录, 而不是2077里的超梦, 科技发展也太慢了吧? 什么时候能去火星啊. 望天.\n","description":"","id":0,"section":"blogs","tags":null,"title":"赛博朋克, 调酒师与现实","uri":"/blogs/va11/"},{"content":"LeetCode 174\nA False Example We demonstrate a false example to show that there is no top-down, left-right dp solution to this problem.\n We need to test all possible paths from $(0,0)$ to $(i,j)$, find the lowest bound of the path sum along each path, from start to end. (Actually the value is lowest bound + 1, which keeps the knight alive) Keep two tables, $dpSum[i][j]$ records the path sum to have $dpMin[i][j]$, which records the lowest bound upon current position along this path.  If we have both $(i-1, j)$ and $(i, j-1)$ for above two tables, do we have $dp[i][j]$ ? The answer is no. Think about it.\nSolution Actually we need to calculate at a bottom-up, right-left order. Let $dp[i][j]$ to be the lowest HP to start from $(i,j)$ to the end, we have:\n$$dp[i][j] = \\begin{cases} min(dp[i][j-1], dp[i-1][j]) - grid[i][j], \u0026amp; \\text{$min(dp[i][j-1], dp[i-1][j]) - grid[i][j] \u0026gt; 0$} \\\\ 1, \u0026amp; \\text{$min(dp[i][j-1], dp[i-1][j]) - grid[i][j] \\leq 0$} \\end{cases}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution:\rdef calculateMinimumHP(self, grid: List[List[int]]) -\u0026gt; int:\rn_row, n_col = len(grid), len(grid[0])\rdp = [[float(\u0026#39;inf\u0026#39;)]*n_col for _ in range(n_row)]\rdp[n_row-1][n_col-1] = 1 - min(0, grid[n_row-1][n_col-1])\r# init last row and col\r for i in range(n_row-2, -1, -1):\rneed = dp[i+1][n_col-1] - grid[i][n_col-1]\rdp[i][n_col-1] = need if need \u0026gt; 0 else 1\rfor j in range(n_col-2, -1, -1):\rneed = dp[n_row-1][j+1] - grid[n_row-1][j]\rdp[n_row-1][j] = need if need \u0026gt; 0 else 1\r# init dp table\r for i in range(n_row-2, -1, -1):\rfor j in range(n_col-2, -1, -1):\rneed = min(dp[i+1][j], dp[i][j+1]) - grid[i][j]\rdp[i][j] = need if need \u0026gt; 0 else 1\rreturn dp[0][0]\r  ","description":"","id":1,"section":"playground","tags":["dynamic programming"],"title":"Dungeon Game","uri":"/playground/dungeon-game/"},{"content":"LeetCode 730\nThe problem seems to be similar to Longest Palindromic Subsequence, but tt\u0026rsquo;s hard to enumerate all the subsequences since it goes to $O(2^n)$ complexity.\nActually, the distinct subsequence is similar to Distinct Subsequences II. We could use the method called Sequence Automata. Check: 序列自动机总结与例题, 序列自动机\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution:\rdef init_next(self, s: str, a: int) -\u0026gt; List[List[int]]:\rn = len(s) - 1\rget_next = [[0]*a for _ in range(n+1)]\rfor i in range(n, 0, -1):\rfor c in range(a):\rget_next[i-1][c] = get_next[i][c]\rget_next[i-1][ord(s[i])-ord(\u0026#39;a\u0026#39;)] = i\rreturn get_next\rdef countPalindromicSubsequences(self, S: str) -\u0026gt; int:\rs1, s2, n, a, mod = \u0026#39; \u0026#39;+S, \u0026#39; \u0026#39;+S[::-1], len(S), 4, 10**9+7\rnext1, next2 = self.init_next(s1, a), self.init_next(s2, a)\rdef dfs(i, j) -\u0026gt; int:\rans = 0\rfor c in range(a):\ri_n, j_n = next1[i][c], next2[j][c]\rif i_n and j_n:\rif i_n + j_n \u0026gt; n + 1: continue\rif i_n + j_n \u0026lt; n + 1: ans += 1\rans = (ans + dfs(i_n, j_n)) % mod\rreturn ans + 1\rreturn dfs(0, 0) - 1\r  ","description":"","id":2,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Count Different Palindromic Subsequences","uri":"/playground/count-different-palindromic-subsequences/"},{"content":"LeetCode 516\nThis is similar to Longest Palindromic Substring, but it is hard to use the expanding idea cuz the subsequence is not continuous. We can try to use the dp idea as an initial:\nLet $dp[i][j]$ to be the longest palindromic substring for $s[i, j]$, then:\n$$ dp[i][j] = \\begin{cases} dp[i+1][j-1] + 2, \u0026amp; \\text{$s[i]=s[j]$} \\\\ \\max\\lbrace dp[i][j-1], dp[i+1][j] \\rbrace, \u0026amp; \\text{$s[i] \\neq s[j]$} \\\\ 1, \u0026amp;\\text{$i=j$} \\\\ 0, \u0026amp;\\text{$i\u0026gt;j$} \\end{cases} $$\n\rdp[i][j-1]\u0026lt;--dp[i][j]\r/ |\r/ |\rdp[i+1][j-1] dp[i+1][j]\rCorner Cases There are two corner cases as listed above, $i=j$ and $i\u0026lt;j$, we need to initialize them first.\n   i\\j 0 1 2 3 4     0 1 a c f j   1 0 1 b e i   2  0 1 d h   3   0 1 g   4    0 1    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution:\rdef longestPalindromeSubseq(self, s: str) -\u0026gt; int:\rn = len(s)\rif n == 0: return 0\rdp = [[0]*n for _ in range(n)]\r# init two corner cases\r for i in range(n):\rdp[i][i] = 1\rfor i in range(1, n):\rdp[i][i-1] = 0\r# filling the table\r for j in range(1, n):\rfor i in range(j-1, -1, -1):\rif s[i] == s[j]:\rdp[i][j] = dp[i+1][j-1] + 2\relse:\rdp[i][j] = max(dp[i+1][j], dp[i][j-1])\rreturn dp[0][n-1]\r  Backtracking Solution WIP\n","description":"","id":3,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Longest Palindromic Subsequence","uri":"/playground/longest-palindromic-subsequence/"},{"content":"leetcode 152\nThe idea is the same like Maximum Subarray, let $dp[i]$ to be the maximum product subarray value that ends at $nums[i]$, but we have some issues here:\n If $dp[i-1] = 3$, while the minimum product subarray value that ends at $i$ is $-4$ and $nums[i] = -1$, then we get $-4 \\cdot -1 \u0026gt; 3 \\cdot -1$ Apparently we need to record the minimum product subarray as well, and we compare all the values.  $$ dp[i] = \\max \\lbrace dp_{min}[i-1] \\cdot nums[i], dp_{max}[i-1] \\cdot nums[i], nums[i] \\rbrace $$\n1 2 3 4 5 6 7 8 9 10  class Solution:\rdef maxProduct(self, nums: List[int]) -\u0026gt; int:\rn, max_prod = len(nums), nums[0]\rdp = [{\u0026#39;max\u0026#39;:0, \u0026#39;min\u0026#39;:0} for _ in range(n)]\rdp[0][\u0026#39;max\u0026#39;], dp[0][\u0026#39;min\u0026#39;] = nums[0], nums[0]\rfor i in range(1, n):\rdp[i][\u0026#39;max\u0026#39;] = max(dp[i-1][\u0026#39;max\u0026#39;]*nums[i], dp[i-1][\u0026#39;min\u0026#39;]*nums[i], nums[i])\rdp[i][\u0026#39;min\u0026#39;] = min(dp[i-1][\u0026#39;max\u0026#39;]*nums[i], dp[i-1][\u0026#39;min\u0026#39;]*nums[i], nums[i])\rmax_prod = max(max_prod, dp[i][\u0026#39;max\u0026#39;])\rreturn max_prod\r  ","description":"","id":4,"section":"playground","tags":["dynamic programming"],"title":"Maximum Product Subarray","uri":"/playground/maximum-product-subarray/"},{"content":"leetcode 140\nThis is pretty much an easier version of Palindrome Partitioning, cuz finding a word is much easier than finding a valid palindrome substring.\nUsing a backtracking method:\n When a substring is breakable, we iterate this substring and find all possible break positions. Dfs search each possible breaks. If search ends, we find a match.  Corner Cases: We can handle the situaion which search string is '', so we can put the terminal condition in the self.breakable()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  class Solution:\rdef breakable(self, s: str, wordDict: List[str]) -\u0026gt; bool:\rn = len(s)\rdp = [False]*(n+1)\rdp[0] = True\rfor i in range(1, n+1):\rfor n in range(i+1):\rif dp[n] and s[n:i] in wordDict:\rdp[i] = True\rbreak\rreturn dp[n]\rdef wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]:\rn = len(s)\rresults: List[str] = []\rdef search(i:int, path: List[str]):\rif i == n:\rresults.append(\u0026#39; \u0026#39;.join(path))\rif self.breakable(s[i:], wordDict):\rfor j in range(i, n):\rsub_str = s[i:j+1]\rif sub_str in wordDict:\rsearch(j+1, path+[sub_str])\rsearch(0, [])\rreturn results\r  ","description":"","id":5,"section":"playground","tags":["dynamic programming","backtracking","dfs"],"title":"Word Break 2","uri":"/playground/word-break-2/"},{"content":"leetcode 139\nThis is an easy version of Longest Palindromic Substring, cuz finding a word is much easier than finding a valid palindrome substring.\nLet $dp[i]$ to be if $s[0, i]$ is a valid break, we have:\n If $s[0, n]$ is a valid break and $s[n+1, i]$ is in the dict $S$, then $s[0, i]$ is a valid break. i.e.\n$$ dp[n] \\land \\lbrace s[n+1, i] \\in S \\rbrace \\to dp[i] $$\n It looks like we need to firstly iterate the $s$, and iterate substring at each position $i$, which makes it $O(n^2)$ complexity. When we find a match in the substring, we can stop the iteration.\nCorner Cases If we check substring from $s[0, i]$, then we don\u0026rsquo;t have $dp[-1]$, we can insert a True to the $dp$ table, and be careful of the index changes:\n When indexing $dp$, $[0, n-1] \\to [1, n]$ when indexing $s$, we need to use $s[i-1]$  $$dp[i] = \\bigcap_{n=0}^{i} \\left\\lbrace dp[n] \\land \\lbrace s[n+1, i] \\in S \\rbrace \\right\\rbrace $$\n1 2 3 4 5 6 7 8 9 10 11  class Solution:\rdef wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; bool:\rn = len(s)\rdp = [False]*(n+1)\rdp[0] = True\rfor i in range(1, n+1):\rfor n in range(i+1):\rif dp[n] and s[n:(i-1)+1] in wordDict:\rdp[i] = True\rbreak\rreturn dp[n]\r  ","description":"","id":6,"section":"playground","tags":["dynamic programming"],"title":"Word Break","uri":"/playground/word-break/"},{"content":"LeetCode 132\nWe need to borrow the idea from Longest Palindromic Substring, using the ad-hoc method, try to expand at each index as the center.\nLet $dp[i]$ to be the minimum cuts for $s[0, i]$, initialize it to the maximum cuts, which is $i-1$ (in 0-based indexing, it is $i$)\nBy using the expanding idea, when we get a palindrome substring $s[l, r]$, the minimum cuts for $s[0, r]$ shrinks into $dp[l-1]+1$. Iterate through all the possible palindrome substrings.\n   a b a c d d c a a a     0 1 0 1 2 2 1 2 2 2    Corner Case When i-1\u0026lt;0, i.e. we have a palindrome substring which starts from 0, e.g. s=abc, r=2, then the dp[0-1]=0, means we don\u0026rsquo;t need any cut for string abc cuz it itself is a palindrome substring.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution:\rdef minCut(self, s: str) -\u0026gt; str:\rn = len(s)\rdp = [i for i in range(n)]\rfor i in range(n):\rfor j in range(i+1):\rl, r = i-j, i+j\rif l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]:\rdp[r] = min(dp[r], dp[l-1]+1 if l-1\u0026gt;=0 else 0)\relse:\rbreak\rfor j in range(i+1):\rl, r = i-1-j, i+j\rif l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]:\rdp[r] = min(dp[r], dp[l-1]+1 if l-1\u0026gt;=0 else 0)\relse:\rbreak\rreturn dp[-1]\r  ","description":"","id":7,"section":"playground","tags":["dynamic programming"],"title":"Palindrome Partitioning 2","uri":"/playground/palindrome-partitioning-2/"},{"content":"LeetCode 131\nAlthough this is similar to Longest Palindromic Substring, yet the idea is similar to Word Break 2. We use backtracking at each place it could be partitioned.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution:\rdef partition(self, s: str) -\u0026gt; List[List[str]]:\rn = len(s)\rresults: List[List[str]] = []\rdef search(i, path: List[str]):\rif i == n: results.append(path)\rfor j in range(i, n):\rsub = s[i:j+1]\rif sub == sub[::-1]:\rsearch(j+1, path+[sub])\rsearch(0, [])\rreturn results\r  ","description":"","id":8,"section":"playground","tags":["backtracking","dfs"],"title":"Palindrome Partitioning","uri":"/playground/palindrome-partitioning/"},{"content":"LeetCode 188\nSay you have an array for which the i-th element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most k transactions.\nDP Solution Let dp[i][j] to be the maximum profit to buy and sell the stock with at most i operations at t=j.\nFor any given time t, we have two options:\n Do nothing, or buy the stock, the profit remains unchanged: dp[i][j] = dp[i][j-1] Sell the stock. We must buy the stock first. Assume that we but the stock at $t \\in [0, j-1]$  We have already gained profit dp[i-1][t-1] Buy the stock: -prices[t] Sell the stock: prices[j]\nTotal profit: dp[i-1][t-1] - prices[t] + prices[j]   We need to iterate through all possible buying time:  $$ dp[i][j] = \\max \\left\\lbrace dp[i][j-1], \\max\\limits_{t \\in [0, j-1]} \\left\\lbrace dp[i-1][t-1] - p[t] \\right\\rbrace + p[j] \\right\\rbrace $$\nNotice the 2nd term, we let $M_j=\\max\\limits_{t \\in [0, j-1]} \\left\\lbrace dp[i-1][t-1] - p[t] \\right\\rbrace$ and $ m_{t} = dp[i-1][t-1] - p[t] $:\n$$ M_{j} = \\max\\limits_{t \\in [0, j-1]} \\lbrace m_{t} \\rbrace = \\max \\left\\lbrace M_{j-1}, m_{j-1} \\right\\rbrace $$\nAt each iteration $i, j$, we could calculate $m_{j}=dp[i-1][j-1]-p[j]$ for the next iteration in advance. Because in current iteration we already have the data of dp[i-1][x]. Thus we can get rid of the inner loop and calculate $M_j$ in an iterative way.\nCorner Cases We start from $i=1, j=1$ to avoid corner cases. For $i=0$ or $j=0$, $dp[i][j]=0$, so we don\u0026rsquo;t need additional init steps.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution:\rdef quickSolve(self, prices: List[int]) -\u0026gt; int:\rprofit = 0\rfor i in range(1, len(prices)):\rif prices[i] \u0026gt; prices[i - 1]:\rprofit += prices[i] - prices[i-1]\rreturn profit\rdef maxProfit(self, k: int, prices: List[int]) -\u0026gt; int:\rif k \u0026gt;= len(prices) // 2: return self.quickSolve(prices)\rdp = [[0]*len(prices) for _ in range(k+1)]\rfor i in range(1, k+1):\rtmp_max = -prices[0]\rfor j in range(1, len(prices)):\rdp[i][j] = max(dp[i][j-1], tmp_max + prices[j])\rtmp_max = max(tmp_max, dp[i-1][j-1] - prices[j])\rreturn dp[k][-1]\r  ","description":"","id":9,"section":"playground","tags":["dynamic programming"],"title":"Best Time to Buy and Sell Stock Iv","uri":"/playground/best-time-to-buy-and-sell-stock-iv/"},{"content":"LeetCode 120\nThe method is identical to [Minimal Path Sum](/playground/minimal-path-sum/, only that the shape changes from rectangle to triangle.\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution:\rdef minimumTotal(self, triangle: List[List[int]]) -\u0026gt; int:\rn_row = len(triangle)\rdp = [[] for _ in range(n_row)]\rdp[0].append(triangle[0][0])\rfor i in range(1, n_row):\rfor j in range(i+1):\rtop_left = dp[i-1][j-1] if j-1\u0026gt;=0 else float(\u0026#34;inf\u0026#34;)\rtop_right = dp[i-1][j] if j \u0026lt; len(triangle[i-1]) else float(\u0026#34;inf\u0026#34;)\rminimal = min(top_left, top_right) + triangle[i][j]\rdp[i].append(minimal)\rreturn min(dp[-1])\r  Notes\n Init the first element manually Init the dp table by appending instead of indexing For each element to iterate, check left bound for top left, check right bound for top right ","description":"","id":10,"section":"playground","tags":["dynamic programming"],"title":"Triangle","uri":"/playground/triangle/"},{"content":"Leetcode 115\nThis problem is quite similar to Interleaving String, but the solution is almost the same as Regular Expression Matching: we build top-down solution by backtracking, then build bottom-up solution of dp.\nIntro problem Let\u0026rsquo;s discuss a simplified problem: How to check if t is a subsequence of s? Using a greddy strategy, this would be quite straight forward:\n Iterate through s, match t in a greddy manner.\n  If t has been iterated over, we find a match. If s has been iterated over, we need to iterate over t as well, or there\u0026rsquo;s no match, search over. If not 1 or 2, we need to continue searching, skip the characters in s[0] which don\u0026rsquo;t match t[0]  1 2 3 4 5 6 7 8 9 10 11 12 13  def is_subsequence(s: str, t: str) -\u0026gt; bool:\rdef search(i: int, j: int) -\u0026gt; bool:\rwhile i\u0026lt;len(s) and j\u0026lt;len(t) and s[i] != t[j]:\ri += 1\rif j == len(t):\rreturn True\relif i == len(s):\rreturn False\relse:\rreturn search(i+1, j+1)\rreturn search(0, 0)\r  Backtracking Borrowing the idea from last section, we need to count all of the possible match, so we can\u0026rsquo;t stop when we find a character matches, we need to skip this match and explore if there\u0026rsquo;re other possibilities to achieve a match.\nWe define search(i, j) to be the distinct subsequences for s[i:] and t[j:], despite that we search for the current match, we still goes for further possibilities in s\n1 2 3 4 5 6 7 8 9 10 11 12 13  def numDistinct(self, s: str, t: str) -\u0026gt; int:\rdef search(i, j):\rwhile i\u0026lt;len(s) and j\u0026lt;len(t) and s[i] != t[j]:\ri += 1\rif j == len(t):\rreturn 1\relif i == len(s):\rreturn 0\relse:\rreturn search(i+1, j+1) + search(i+1, j)\rreturn search(0, 0)\r  Note:\n We can easily optimize time complexity by using a cache to avoid duplicate calculation. See Optimize Recursion.  Dynamic Programming WIP\n","description":"","id":11,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Distinct Subsequences","uri":"/playground/distinct-subsequences/"},{"content":"Leetcode 97\nDescription Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\nExample:\nInput: s1 = \u0026quot;aabcc\u0026quot;, s2 = \u0026quot;dbbca\u0026quot;, s3 = \u0026quot;aadbbcbcac\u0026quot;\rOutput: true\rExplanation: aadbbcbcac, aadbbcbcac are all valid interpretations for the interleaving.\nNotice:\n The order of the strings cannot be changed, which indicates that we can construct s3 using s1 and s2 from their substrings. Different ways of interleaving can led to same results.  Example of constructing a string We define $dp[i][j]$ as: If $a3[0, i+j]$ can be constructed by $a1[0, i]$ and $a2[0, j]$\nWe have 2 choices to construct $a3[0, i+j+1]$: using $a1[i+1]$ or $a2[j+1]$\n1 2  if dp[i][j] and s1[i+1] == s3[i+j+1]: dp[i+1][j] = True # Use s1[i+1] to construct s3[i+j+1]\r if dp[i][j] and s2[j+1] == s3[i+j+1]: dp[i][j+1] = True # Use s2[j+1] to construct s3[i+j+1]\r   So we have 2 ways to get the needed dp[i][j]\n1 2  use_s1 = dp[i-1][j] and s1[i] == s3[i+j]\ruse_s2 = dp[i][j-1] and s2[j] == s3[i+j]\r  i.e.\n1  dp[i][j] = use_s1 or use_s2\r  Corner Cases If $i=0, j=5$, it represents that if $a3[0, 5]$ can be constructed by $s1=\\varnothing$ and $s2[0,5]$, we only need to check that if $s2[0,5] = s3[0,5]$\nIf we use 0-based index, this situation corresponding to dp[-1][4], which is not quite convenience. Using 1-based indexing we could initialize the first row and col and then calculating the dp table from dp[1][1]\n    0 d b b c a     0 T F F F F F   a T F F F F F   a T T T T F F   b F T T F F F   c F F T T T T   c F F F T F T    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution:\rdef isInterleave(self, s1: str, s2: str, s3: str) -\u0026gt; bool:\rif len(s1) + len(s2) != len(s3): return False\rm, n = len(s1), len(s2)\rdp = [[False]*(n+1) for _ in range(m+1)]\rfor i in range(n+1): # s1 is empty\r dp[0][i] = s2[:i] == s3[:i]\rfor i in range(m+1): # s2 is empty\r dp[i][0] = s1[:i] == s3[:i]\rfor i in range(1, m+1):\rfor j in range(1, n+1):\ruse_s1 = dp[i-1][j] and s1[i-1] == s3[i+j-1]\ruse_s2 = dp[i][j-1] and s2[j-1] == s3[i+j-1]\rdp[i][j] = use_s1 or use_s2\rreturn dp[-1][-1]\r  Note:\n Under 1-based indexing, take care of the indexing on s1, s2 and s3. ","description":"","id":12,"section":"playground","tags":["dynamic programming"],"title":"Interleaving String","uri":"/playground/interleaving-string/"},{"content":"Leetcode 639\nSame as Decode Ways, we only need to add some cases on wildcard matching, in which we could match multiple patterns for S[i]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution:\rdef numDecodings(self, s: str) -\u0026gt; int:\rone = {str(k):1 for k in range(1, 10)}\rone.update({\u0026#39;*\u0026#39;:9})\rtwo = {str(k):1 for k in range(10, 27)}\rtwo.update({\r\u0026#39;*0\u0026#39;: 2, \u0026#39;*1\u0026#39;: 2, \u0026#39;*2\u0026#39;: 2, \u0026#39;*3\u0026#39;: 2, \u0026#39;*4\u0026#39;: 2, \u0026#39;*5\u0026#39;: 2, \u0026#39;*6\u0026#39;: 2, \u0026#39;*7\u0026#39;: 1, \u0026#39;*8\u0026#39;: 1, \u0026#39;*9\u0026#39;: 1, \u0026#39;1*\u0026#39;: 9, \u0026#39;2*\u0026#39;: 6, \u0026#39;**\u0026#39;: 15\r})\rdp = [0]*len(s)\rfor i in range(len(s)):\rmatch_one = one.get(s[i], 0)\rmatch_two = two.get(s[i-1:i+1], 0) if i-1\u0026gt;=0 else 0\rone_bit = dp[i-1]*match_one if i-1\u0026gt;=0 else match_one\rtwo_bit = dp[i-2]*match_two if i-2\u0026gt;=0 else match_two\rdp[i] = one_bit + two_bit\rreturn dp[-1] % (10**9+7)\r  ","description":"","id":13,"section":"playground","tags":["dynamic programming"],"title":"Decode Ways 2","uri":"/playground/decode-ways-2/"},{"content":"Leetcode 91\nThis is a 1-d DP. Set $dp[i]$ to be the decode ways for s[:i+1], we have:\n$$ dp[i] = dp[i-2] \\cdot M^{1}_{i} + dp[i-1] \\cdot M^{2}_{i} $$\nIn which,\n$$ \\begin{aligned} M^{1}_{i} \u0026amp;= | \\lbrace S[i] \\in A^{1} \\rbrace | \\\\ M^{2}_{i} \u0026amp;= | \\lbrace S[i-1:i+1] \\in A^{2} \\rbrace \\end{aligned} $$\n $M^{1}_{i}$ means how many ways to match the 1-character decoders $A^1$ with $S[i]$. In this problem we have either 1($S[i] \\in A^{1}$) or 0(not match, or not exists) $M^{2}_{i}$ means how many ways to match the 2-character decoders $A^2$ with $S[i-1:i+1]$. In this problem we have either 1($S[i] \\in A^{1}$) or 0(not match, or not exists)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef numDecodings(self, s: str) -\u0026gt; int:\rone = {str(k):1 for k in range(1, 10)}\rtwo = {str(k):1 for k in range(10, 27)}\rdp = [0]*len(s)\rfor i in range(len(s)):\rmatch_one = one.get(s[i], 0)\rmatch_two = two.get(s[i-1:i+1], 0) if i-1\u0026gt;=0 else 0\rone_bit = dp[i-1]*match_one if i-1\u0026gt;=0 else match_one\rtwo_bit = dp[i-2]*match_two if i-2\u0026gt;=0 else match_two\rdp[i] = one_bit + two_bit\rreturn dp[-1]\r  Notes\n Use get() to take care of cases when s[i] is not in one Take care of the corner cases when $i \u0026lt;= 2$, in which we can\u0026rsquo;t get dp values. Follow Up: Decode Ways 2 ","description":"","id":14,"section":"playground","tags":["dynamic programming"],"title":"Decode Ways","uri":"/playground/decode-ways/"},{"content":"LeetCode 84\nThe idea is somewhat similar to Longest Valid Parentheses, in which:\n Maintain a stack which stores the indices Calculate the target function each time an element pops out from the stack Take care of the corner case with -1 when we don\u0026rsquo;t have the leftmost element  Maintain a stack of indices, in which:\n All the elements in the stack follows ascending order. The elements popped out between adjacent elements remains in the stack are all taller, i.e. $$height[stack[j]] \u0026lt;= height[k], \\ \\forall k \\in [stack[j-1], stack[j]]$$ So for any element $j$ popped out  leftmost element is $stack[-1] + 1$ rightmost element is current index $i-1$ the width is $(i-1)-(stack[-1]+1)+1=i-stack[-1]-1$    \rBefore height[3] enterAfter height[3] enter\r\r   0 1 2 3 4        x      x x     x x x x   x x x x x    \r   0 1 4       o     o    x x   x x x     \r when 3 pops, the leftmost is 1+1=2, rightmost is 4-1=3  1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution:\rdef largestRectangleArea(self, heights):\rstack, max_area = [], 0\rheights.append(0)\rfor i in range(len(heights)):\rwhile stack and heights[i] \u0026lt; heights[stack[-1]]:\rpopped_idx = stack.pop()\rheight = heights[popped_idx]\rleft = stack[-1] + 1 if stack else 0\rright = max(i-1, 0)\rwidth = right - left + 1\rmax_area = max(max_area, height*width)\rstack.append(i)\rreturn max_area\r  Notes:\n To ensure that left and right is valid, watch out for the corner cases when calculating. Append 0 to heights to ensure it pop out all the elements in the stack. ","description":"","id":15,"section":"playground","tags":["stack"],"title":"Largest Rectangle in Histogram","uri":"/playground/largest-rectangle-in-histogram/"},{"content":"LeetCode 85\nBorrow the idea from Largest Rectangle in Histogram, we can take the matrix as many histograms for each row level, in which we scan from top to down cumulatively to construct it:\n\rMatrixHistograms\r\r   1 1 0 0     1 0 1 0   0 1 1 0   0 1 1 1   1 1 1 1    \r   1 1 0 0     2 0 1 0   0 1 2 0   0 2 3 1   1 3 4 2     \r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class Solution:\rdef largestRectangleArea(self, heights):\rstack, max_area = [], 0\rheights.append(0)\rfor i in range(len(heights)):\rwhile stack and heights[i] \u0026lt; heights[stack[-1]]:\rpopped_idx = stack.pop()\rheight = heights[popped_idx]\rleft = stack[-1] + 1 if stack else 0\rright = max(i-1, 0)\rwidth = right - left + 1\rmax_area = max(max_area, height*width)\rstack.append(i)\rreturn max_area\rdef maximalRectangle(self, matrix: List[List[str]]) -\u0026gt; int:\rn_row, n_col = len(matrix), len(matrix[0])\rmax_area = 0\rheights = [0]*n_col\rfor i in range(n_row):\rfor j in range(n_col):\rif matrix[i][j] == \u0026#34;1\u0026#34;:\rheights[j] += 1\relse:\rheights[j] = 0\rmax_area = max(max_area, self.largestRectangleArea(heights))\rreturn max_area\r  Notes\n Actually this is not a dp solution ","description":"","id":16,"section":"playground","tags":["dynamic programming"],"title":"Maximal Rectangle","uri":"/playground/maximal-rectangle/"},{"content":"This is about calculation Levenshtein Distance\nLeetCode 72\nLevenshtein Distance Check Levenshtein Distance for information.\nLet $\\operatorname{lev}_{a,b}(i,j)$ be the distance between the first $i$ characters of $a$ and the first $j$ characters of $b$. $i$ and $j$ are 1-based indices. We have:\n$$ \\operatorname {lev}_{a,b}(i,j) = \\begin{cases} \\max(i,j) \u0026amp; \\text{ if $min(i,j)=0$}, \\\\ \\min {\\begin{cases} \\operatorname {lev}_{a,b}(i-1,j)+1 \\\\ \\operatorname {lev}_{a,b}(i,j-1)+1 \\\\ \\operatorname {lev}_{a,b}(i-1,j-1)+1_{(a_{i} \\neq b_{j})} \\end{cases}} \u0026amp;{\\text{otherwise.}} \\end{cases} $$\nExplanation For simplification, Let dp[i][j] represent $\\operatorname{lev}_{a,b}(i,j)$.\nWe have 3 ways to reach dp[i][j]. Take a='abxy', b='abc' as an example:\n From dp[i-1][j]: Having abx -\u0026gt; abc, we need one extra del step:  abxy -\u0026gt; abcy (del y)-\u0026gt; abc   From dp[i][j-1]: Having abxy -\u0026gt; ab, we need one extra add step:  abxy -\u0026gt; ab (add c)-\u0026gt; abc   From dp[i-1][j-1]: Having abx -\u0026gt; ab, we need one extra replace step:  abxy -\u0026gt; aby (replace y to c)-\u0026gt; abc If a[i] == b[j], We could skip the replace step.    DP Solution Then we consider the corner cases. We have 0-indexing system, in which situation we can achive -1 indexing.\n If i = -1 or j = -1, then we need to convert an empty string to another non-empty string, by inserting, the cost is the length of the non-empty string, in the above example, when i=-1 and j=1, we convert '' to ab, the cost is 2, dp[i][j] = j+1 = 2 If i = -1 and j = -1, we convert an empty string to another empty string, dp[-1][-1] = 0  There are two strategies to take care of these situations.\n Using a custom indexing system to take care of index overflow. We could use the dp as it was. Taking care of the indexing on the fly. This is less readable than method 1, personally not recommended. Add an extra row and column, start from (1,1) instead of (0,0), which has pros and cons compared to method 1.  We use method 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution:\rdef minDistance(self, word1: str, word2: str) -\u0026gt; int:\rm, n = len(word1), len(word2)\rif m == 0 and n == 0: return 0\relif m == 0: return n\relif n == 0: return m\rdp = [[float(\u0026#34;inf\u0026#34;)]*n for _ in range(m)]\rdef index(i, j):\rif i == -1 and j == -1: return 0\relif i == -1: return j+1\relif j == -1: return i+1\relse: return dp[i][j]\rfor i in range(m):\rfor j in range(n):\rcost = int(word1[i]!=word2[j])\rdp[i][j] = min(index(i-1,j)+1, index(i,j-1)+1, index(i-1,j-1)+cost)\rreturn dp[-1][-1]\r  This method has problem to deal with empty string, in which we generate the result in index() on the fly, which is out of the dp table itself. Try method 3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef minDistance(self, word1: str, word2: str) -\u0026gt; int:\rm, n = len(word1), len(word2)\rdp = [[float(\u0026#34;inf\u0026#34;)]*(n+1) for _ in range(m+1)]\rdp[0][0] = 0\rfor i in range(1, n+1):\rdp[0][i] = i\rfor j in range(1, m+1):\rdp[j][0] = j\rfor i in range(1, m+1):\rfor j in range(1, n+1):\rcost = int(word1[i-1]!=word2[j-1])\rdp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost)\rreturn dp[-1][-1]\r  Notes:\n word index changes from i, j to i-1, j-1 in method 3. We may optimize the space of the code to use only two vectors, or even one. ","description":"","id":17,"section":"playground","tags":["dynamic programming"],"title":"Edit Distance","uri":"/playground/edit-distance/"},{"content":"LeetCode 64\nThis is pretty much like unique paths.\nLet $dp[i][j]$ to be the total unique paths to $board[i][j]$, the state transision is easy to find:\n$$ dp[i][j] = \\min \\lbrace dp[i-1][j], dp[i][j-1] \\rbrace + grid[i][j] $$\nAs in the unique paths, we define a custom indexing function to take care of corner cases.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution:\rdef minPathSum(self, grid: List[List[int]]) -\u0026gt; int:\rn_row, n_col = len(grid), len(grid[0])\rmin_sum = float(\u0026#34;inf\u0026#34;)\rdef index(i, j):\rif i in range(n_row) and j in range(n_col):\rreturn dp[i][j]\relse:\rreturn float(\u0026#34;inf\u0026#34;)\rdp = [[float(\u0026#34;inf\u0026#34;)]*n_col for _ in range(n_row)]\rdp[0][0] = grid[0][0]\rfor i in range(n_row):\rfor j in range(n_col):\rif i == 0 and j == 0:\rcontinue\rdp[i][j] = min(index(i-1, j), index(i, j-1)) + grid[i][j]\rreturn dp[n_row-1][n_col-1]\r  ","description":"","id":18,"section":"playground","tags":["dynamic programming"],"title":"Minimal Path Sum","uri":"/playground/minimal-path-sum/"},{"content":"Walk over all grids without duplicate, with obstacles\nDescription See LeetCode 980\nDFS Backtracking Solution Unlike the DP solutions to Unique path 1 and 2, we cannot reuse calculated paths cuz we can walk forth and back into the same arange (i, j). And the start and end position varies. Using a DFS.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution:\rdef uniquePathsIII(self, grid: List[List[int]]) -\u0026gt; int:\rn_row, n_col = len(grid), len(grid[0])\rself.count, empty = 0, 1\r# find start and end, count empty grids\r for i in range(n_row):\rfor j in range(n_col):\rif grid[i][j] == 0:\rempty += 1\rif grid[i][j] == 1:\rstart = [i, j]\rif grid[i][j] == 2:\rend = [i, j]\rdef search(i, j, empty):\rif i in range(n_row) and j in range(n_col) and grid[i][j] \u0026gt;= 0:\rif ([i, j] == end) and (empty == 0):\rself.count += 1\rreturn\rgrid[i][j] = -2\rsearch(i-1, j, empty-1)\rsearch(i+1, j, empty-1)\rsearch(i, j-1, empty-1)\rsearch(i, j+1, empty-1)\rgrid[i][j] = 0\rsearch(start[0], start[1], empty)\rreturn self.count\r  Note\n We initialize empty with 1, cuz the start of the search counts. Search in a grid is frequently used, we need to restore the element after search. The search function could be memorized to accelerate. ","description":"","id":19,"section":"playground","tags":["backtracking","dfs"],"title":"Unique Paths 3","uri":"/playground/unique-paths-3/"},{"content":"Count all paths from a to b, with obstacles.\nDescription See LeetCode 63\nDynamic Programming Solution Let $dp[i][j]$ to be the total unique paths to $board[i][j]$, the state transision is easy to find:\n dp[i-1][j]\r^\r|\rdp[i][j-1]\u0026lt;--dp[i][j]\r$$ dp[i][j] = \\begin{cases} dp[i-1][j] + dp[i][j-1], \u0026amp; \\text{$board[i][j] = 0$} \\\\ 0, \u0026amp; \\text{$board[i][j] = 1$} \\end{cases} $$\nWatch out for the initial condition: we con\u0026rsquo;t initialize all values to 1 on the first row and first col.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Solution:\rdef uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u0026gt; int:\rn_row, n_col = len(obstacleGrid), len(obstacleGrid[0])\rdp = [[0]*n_col for _ in range(n_row)]\rif obstacleGrid[0][0] != 1:\rdp[0][0] = 1\rdef index(i, j):\rif i in range(n_row) and j in range(n_col):\rreturn dp[i][j]\relse:\rreturn 0\rfor i in range(n_row):\rfor j in range(n_col):\rif i == 0 and j == 0:\rcontinue\rif obstacleGrid[i][j] == 0:\rdp[i][j] = index(i-1, j) + index(i, j-1)\rreturn dp[n_row-1][n_col-1]\r  ","description":"","id":20,"section":"playground","tags":["dynamic programming"],"title":"Unique Paths 2","uri":"/playground/unique-paths-2/"},{"content":"Count all paths from a to b\nDescription See LeetCode 62\nDynamic Programming Solution Let $dp[i][j]$ to be the total unique paths to $board[i][j]$, the state transision is easy to find:\n dp[i-1][j]\r^\r|\rdp[i][j-1]\u0026lt;--dp[i][j]\r$$ dp[i][j] = dp[i-1][j] + dp[i][j-1] $$\n Define a custom indexing function to take care of corner cases. The filling order is described as follow for $row=3, col=4$:     0 1 2 3     4 5 6 7   8 9 10 11    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution:\rdef uniquePaths(self, m: int, n: int) -\u0026gt; int:\rdp = [[0]*n for _ in range(m)]\rdp[0][0] = 1\rdef index(i, j):\rif i in range(m) and j in range(n):\rreturn dp[i][j]\relse:\rreturn 0\rfor i in range(m):\rfor j in range(n):\rif i == 0 and j == 0:\rcontinue\rdp[i][j] = index(i-1, j) + index(i, j-1)\rreturn dp[m-1][n-1]\r  ","description":"","id":21,"section":"playground","tags":["dynamic programming"],"title":"Unique Paths","uri":"/playground/unique-paths/"},{"content":"Description Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nExample:\nInput: [-2,1,-3,4,-1,2,1,-5,4],\rOutput: 6\rExplanation: [4,-1,2,1] has the largest sum = 6.\nFollow up:\nIf you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nDynamic Programming Solution Let $dp[i]$ to be the maximum subarray value that ends at $nums[i]$, which is all the possible subarray sum which ends at $i$, i.e.\n$$ \\begin{aligned} dp[i] \u0026amp;= \\max_{j \\in [0, i] } \\left\\lbrace \\sum\\limits_{k=j}^{i} nums[k] \\right\\rbrace \\\\ \u0026amp;= \\max_{j \\in [0, i] } \\left\\lbrace \\sum\\limits_{k=j}^{i-1} nums[k],0 \\right\\rbrace + nums[i] \\\\ \u0026amp;= \\max \\left\\lbrace dp[i-1], 0 \\right\\rbrace + nums[i] \\end{aligned} $$\n1 2 3 4 5 6 7  class Solution:\rdef maxSubArray(self, nums: List[int]) -\u0026gt; int:\rdp, max_sum = [0]*len(nums), -float(\u0026#34;inf\u0026#34;)\rfor i in range(len(nums)):\rdp[i] = (max(dp[i-1], 0) if i-1\u0026gt;=0 else 0) + nums[i]\rmax_sum = max(max_sum, dp[i])\rreturn max_sum\r  Notes\n When calculating dp[i-1], watch out for the corner case. Generate max_sum in each iter on the fly. ","description":"","id":22,"section":"playground","tags":["dynamic programming"],"title":"Maximum Subarray","uri":"/playground/maximum-subarray/"},{"content":"Description Given a string containing just the characters \u0026lsquo;(', \u0026lsquo;)', \u0026lsquo;{', \u0026lsquo;}', \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]', determine if the input string is valid.\nAn input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Note that an empty string is also considered valid.\nStack Solution Keep a stack\n When a ( arrives, push it into the stack When a ) arrives, compare it with the top of stack, if it forms a pair, pop it, else push it.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution:\rdef isValid(self, s: str) -\u0026gt; bool:\rleft_set = {\u0026#39;(\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;[\u0026#39;}\rright_set = {\u0026#39;)\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;]\u0026#39;}\rget_pair = {\r\u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;,\r\u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;,\r\u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;\r}\rstack = []\rfor p in s:\rif p in left_set:\rstack.append(p)\relse:\rif stack and stack[-1] == get_pair[p]:\rstack.pop()\relse:\rstack.append(p)\rreturn len(stack) == 0\r  Notes\n We use a dict to check if the pair is valid. Watch out for corner case before indexig. Follow up ","description":"","id":23,"section":"playground","tags":["stack"],"title":"Valid Parentheses","uri":"/playground/valid-parentheses/"},{"content":"Description Given a string containing just the characters \u0026lsquo;(\u0026rsquo; and \u0026lsquo;)', find the length of the longest valid (well-formed) parentheses substring.\nExample 1:\nInput: \u0026quot;(()\u0026quot;\rOutput: 2\rExplanation: The longest valid parentheses substring is \u0026quot;()\u0026quot;\rExample 2:\nInput: \u0026quot;)()())\u0026quot;\rOutput: 4\rExplanation: The longest valid parentheses substring is \u0026quot;()()\u0026quot;\rDynamic Programming Solution Let $dp[i]$ to be the length of the longest valid parentheses which ends at $i$'th position.\n $s[i]$ must be ) to have a valid parentheses, else $dp[i] = 0$\n Depends on s[i-1], we have 2 situations:\n $s[i-1] = ($     \u0026hellip; i-2 i-1 i     \u0026hellip; . ( )    dp[i-2] 0 dp[i]    dp[i] = dp[i-2] + 2\r$s[i-1] = )$\nwe have 2 situations, only needs to consider $s[i-dp[i-1]-1] = ($     i-dp[i-1]-2 i-dp[i-1]-1 i-dp[i-1] \u0026hellip; i-1 i     ? ( ( \u0026hellip; ) )   dp[i-dp[i-1]-2] 0 0 \u0026hellip; dp[i-1] dp[i]    dp[i] = dp[i-dp[i-1]-2] + dp[i-1] + 2\rCombining all the situations above, we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef longestValidParentheses(self, s: str) -\u0026gt; int:\rn = len(s)\rdp = [0]*n\r_max = 0\rfor i in range(n):\rif s[i] == \u0026#39;)\u0026#39; and (i-1\u0026gt;=0):\rif s[i-1] == \u0026#39;(\u0026#39;:\rdp[i] = (dp[i-2] if (i-2\u0026gt;=0) else 0) + 2\r_max = max(_max, dp[i])\relse:\rif (i-dp[i-1]-1\u0026gt;=0) and s[i-dp[i-1]-1] == \u0026#39;(\u0026#39;:\rdp[i] = dp[i-1] + 2 + (dp[i-dp[i-1]-2] if (i-dp[i-1]-2\u0026gt;=0) else 0)\r_max = max(_max, dp[i])\rreturn _max\r  Though the DP solution is not quite intuitive for me.\nStack Solution Maintain a stack, which borrows the idea from Valid Parentheses\n When a ( arrives, push it into the stack When a ) arrives, compare it with the top of stack, if it forms a pair, pop it, else push it. After the whole process, the items left in the stack are those not having valid pairs. On the other side, other elements are valid pairs. We just need to find longest space between those elements in the stack. So we push index of the elements, instead of the element itself.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution:\rdef longestValidParentheses(self, s: str) -\u0026gt; int:\rstack: List[int] = []\rmax_len: int = 0\rfor i in range(len(s)):\rif s[i] == \u0026#39;(\u0026#39;:\rstack.append(i)\relif s[i] == \u0026#39;)\u0026#39;:\rif stack and s[stack[-1]] == \u0026#39;(\u0026#39;:\rstack.pop()\rlast_not_paired = stack[-1] if stack else -1\rmax_len = max(max_len, i-last_not_paired)\relse:\rstack.append(i)\rreturn max_len\r  Notes\n We generate the max length on the fly. Each time a pair generated, we calculate space between current element and last element remains in the stack, which is the last index that has not been paired yet, which is the current length of the generated valid substring. Watch out for corner case: if the stack is empty, we cannot find last element that has not been pairs, just put -1 to it shoud be fine. ","description":"","id":24,"section":"playground","tags":["dynamic programming","stack"],"title":"Longest Valid Parentheses","uri":"/playground/longest-valid-parentheses/"},{"content":"Description Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nExample 1:\nInput: \u0026quot;babad\u0026quot;\rOutput: \u0026quot;bab\u0026quot;\rNote: \u0026quot;aba\u0026quot; is also a valid answer.\rExample 2:\nInput: \u0026quot;cbbd\u0026quot;\rOutput: \u0026quot;bb\u0026quot;\rDynamic Programming Solution Let dp[i][j] indicates that s[i:j+1] is a palindromic sequence, we have\n$$ dp[i][j] = \\begin{cases} True, \u0026amp; \\text{$i$ = $j$} \\\\ s[i] = s[j], \u0026amp; \\text{$j$ - $i$ = 1} \\\\ (s[i] = s[j]) \\ \\text{and} \\ dp[i+1][j-1], \u0026amp; \\text{$j$ - $i$ \u0026gt; 1} \\end{cases} $$\n dp[i][j]\r/\rdp[i+1][j-1]\rFilling order is as described below:\n   i\\j b a b a d     b 0 1 3 6 10   a  2 4 7 11   b   5 8 12   a    9 13   d     14    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution:\rdef longestPalindrome(self, s: str) -\u0026gt; str:\rmax_substr = \u0026#34;\u0026#34;\rdp = [[False]*len(s) for _ in range(len(s))]\rfor j in range(len(s)):\rfor i in range(j+1):\rif i == j:\rdp[i][j] = True\relif j-i == 1:\rdp[i][j] = s[i] == s[j]\relse:\rdp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]\rif dp[i][j] and j-i+1 \u0026gt; len(max_substr):\rmax_substr = s[i:j+1]\rreturn max_substr\r  Palindrome Ad-hoc Solution Set $i$ to be the center of palindrome sunstring, $j$ to be the radius, we can expand from center to side to valid the substring:\n Odd length substring:  Expand from $(i, i)$, in which $j=0$, $L=i-j, R=i+j$, length of the substring is $2j+1$, $r_{max} = i$   Even length substring:  Expand from $(i-1, i)$, in which $j=0$, $L=i-1-j, R=i+j$, length of the substring is $2j+2$, $r_{max} = i$       i-j   i-1 i i+1   i+r      1 2 3 4 5 4 3 2 1        i-1 i       1 2 3 4 5 5 4 3 2 1    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class Solution:\rdef longestPalindrome(self, s: str) -\u0026gt; str:\rn, max_len, max_str = len(s), 0, \u0026#34;\u0026#34;\rfor i in range(n):\rfor j in range(i+1):\rl, r = i-j, i+j\rif l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]:\rif max_len \u0026lt; 2*j+1:\rmax_len = 2*j+1\rmax_str = s[l:r+1]\relse:\rbreak\rfor j in range(i+1):\rl, r = i-1-j, i+j\rif l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]:\rif max_len \u0026lt; 2*j+2:\rmax_len = 2*j+2\rmax_str = s[l:r+1]\relse:\rbreak\rreturn max_str\r  Manacher Algorithm Check wiki~ it is O(n)\n","description":"","id":25,"section":"playground","tags":["dynamic programming"],"title":"Longest Palindromic Substring","uri":"/playground/longest-palindromic-substring/"},{"content":"Description Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for \u0026lsquo;?\u0026rsquo; and \u0026lsquo;*'.\n \u0026lsquo;?\u0026rsquo; Matches any single character. \u0026lsquo;*\u0026rsquo; Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).  Note:\n s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *.  Example 1:\nInput:\rs = \u0026quot;aa\u0026quot;\rp = \u0026quot;a\u0026quot;\rOutput: false\rExplanation: \u0026quot;a\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;.\rExample 2:\rInput:\rs = \u0026quot;aa\u0026quot;\rp = \u0026quot;*\u0026quot;\rOutput: true\rExplanation: '*' matches any sequence.\rBacktracking Solution This is an easier version of Regular Expression Matching, since we don\u0026rsquo;t need to check character matching when we get a wildcard. The logic is:\nWe define search(si, pi) as the search function, which means if s[si:] is matched by p[pi:].\nFirst check if it is a wildcard: pi \u0026lt; len(p) and p[pi] == \u0026quot;*\u0026quot;\n If it is, match this or not: search(si+1, pi) or search(si, pi+1) If not, just match current character: si \u0026lt; len(s) and p[pi] in {s[si], \u0026quot;?\u0026quot;}  Search next level: search(si+1, pi+1)    1 2 3 4 5 6 7 8 9 10 11 12  class Solution:\rdef isMatch(self, s: str, p: str) -\u0026gt; bool:\rdef search(si: int, pi: int) -\u0026gt; bool:\rif pi == len(p): return si == len(s)\rwildcard: bool = pi \u0026lt; len(p) and p[pi] == \u0026#34;*\u0026#34;\rif wildcard:\rreturn (si \u0026lt; len(s) and search(si+1, pi)) or search(si, pi+1)\relse:\rmatch: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;?\u0026#34;}\rreturn match and search(si+1, pi+1)\rreturn search(0, 0)\r  Again, it could be optimized through cache.\nDynamic Programming First we can construct state transision from the backtracking method. Jut let search(si, pi) to be dp[si][pi]\n1 2 3 4  dp[si][pi] \u0026lt;--dp[si][pi+1]\r^ \\\r| \\ dp[si+1][pi] dp[si+1][pi+1]\r   We have a (len(s) + 1, len(p) +1) matrix, the iteration order is described below. Starting from dp[len(s)][len(p)-1], we need to get dp[0][0] Set dp[len(s)][len(p)] = True, which indicates our backtracking terminal condition(find a match).     s\\p * a * b      a end    F   b     F   c     F   e     F   b     F       start T    1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution:\rdef isMatch(self, s: str, p: str) -\u0026gt; bool:\rdp: List[List[bool]] = [[False]*(len(p)+1) for _ in range(len(s)+1)]\rdp[len(s)][len(p)] = True\rfor si in range(len(s), -1, -1):\rfor pi in range(len(p)-1, -1, -1):\rwildcard: bool = pi \u0026lt; len(p) and p[pi] == \u0026#34;*\u0026#34;\rif wildcard:\rdp[si][pi] = (si \u0026lt; len(s) and dp[si+1][pi]) or dp[si][pi+1]\relse:\rmatch: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;?\u0026#34;}\rdp[si][pi] = match and dp[si+1][pi+1]\rreturn dp[0][0]\r  ","description":"","id":26,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Wildcard Matching","uri":"/playground/wildcard-matching/"},{"content":"We can easily optimize a recursion by using a cache, which loads calculated function calls during the recursion process.\ncode\rusage\r\r1 2 3 4 5 6 7 8 9 10 11  from functools import wraps\rdef memo(func):\rcache = dict()\r@wraps(func)\rdef wrap(*args):\rif args not in cache:\rcache[args] = func(*args)\rreturn cache[args]\rreturn wrap\r  \r\rSome conditional branches could be merged by and operator.\n1 2 3 4 5 6  @memo\rdef fib(n: int) -\u0026gt; int:\rif n in {0, 1}:\rreturn 1\relse:\rreturn fib(n-1) + fib(n-1)\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"c22a8a98f0324043\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r","description":"","id":27,"section":"playground","tags":null,"title":"Optimize Recursion","uri":"/playground/optimize-recursion/"},{"content":"Description Given an input string (s) and a pattern (p), implement regular expression matching with support for \u0026lsquo;.\u0026rsquo; and \u0026lsquo;*'.\n'.' Matches any single character.\r'*' Matches zero or more of the preceding element.\rThe matching should cover the entire input string (not partial).\rNote:\n s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.  Example :\nInput:\rs = \u0026quot;aab\u0026quot;\rp = \u0026quot;a*b\u0026quot;\rOutput: true\rExplanation: \u0026quot;a*\u0026quot; does not match the entire string \u0026quot;aa\u0026quot;.\rBacktracking Solution We define search(si, pi) as the search function, which means if s[si:] is matched by p[pi:].\nFirst we need to check if p[pi] is a wildcard: p[pi+1] == \u0026quot;*\u0026quot;, and don\u0026rsquo;t forget the corner case: pi+1 \u0026lt; len(p)\n Not wildcard: Just check if s[si] and p[pi] is same character: si \u0026lt; len(s) and s[si] == p[pi]  If it is, search next level: search(si+1, pi+1) If not, just return False, search ends here.   Wildcard: Same as step 1, check if it\u0026rsquo;s the same character:  If it is, that\u0026rsquo;s a valid wildcard match. But we could still choose to match or skip this wildcard: search(si+1, pi) or search(si, pi+2) If not, the only choice is to skip this wildcard: search(si, pi+2)    straight\rconcise\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution:\rdef isMatch(self, s: str, p: str) -\u0026gt; bool:\rdef search(si: int, pi: int) -\u0026gt; bool:\rif pi == len(p): return si == len(s)\rwildcard: bool = pi+1 \u0026lt; len(p) and p[pi+1] == \u0026#34;*\u0026#34;\rmatch: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;.\u0026#34;}\rif wildcard:\rif match:\rreturn search(si+1, pi) or search(si, pi+2)\relse:\rreturn search(si, pi+2)\relse:\rif march:\rsearch(si+1, pi+1)\relse:\rreturn False\rreturn search(0, 0)\r  \r\rSome conditional branches could be merged by and operator.\n1 2 3 4 5 6 7 8 9 10 11 12  class Solution:\rdef isMatch(self, s: str, p: str) -\u0026gt; bool:\rdef search(si: int, pi: int) -\u0026gt; bool:\rif pi == len(p): return si == len(s)\rwildcard: bool = pi+1 \u0026lt; len(p) and p[pi+1] == \u0026#34;*\u0026#34;\rmatch: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;.\u0026#34;}\rif wildcard:\rreturn (match and search(si+1, pi)) or search(si, pi+2)\relse:\rreturn match and search(si+1, pi+1)\rreturn search(0, 0)\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"36e54d76dfffb046\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r  The code could be easily optimized using a cache to avoid duplicate calculation. See Optimize Recursion. Always pay attention to corner cases in recursion. Below is an example for matching aab and c*a*ab, with the dicision tree of the backtracking search path.  graph TD;\rsubgraph DecisionTree\rDROOT(Wildcard?)--\u0026gt;|Y|DL(char?);\rDL--\u0026gt;|Y|DLL(match?);\rDLL--\u0026gt;|Y|DLLL(si+1, pi);\rDLL--\u0026gt;|N|DLLR(si, pi+2);\rDL--\u0026gt;|N|DLR(si, pi+2);\rDROOT--\u0026gt;|N|DR(char?);\rDR--\u0026gt;|Y|DRL(si+1, pi+1);\rDR--\u0026gt;|N|DRR(False);\rend\rsubgraph MatchExample\rROOT(aab,c*a*ab)--\u0026gt;|skip c*|L(aab, a*ab);\rL--\u0026gt;|match a*|LL(ab,a*ab)\rL--\u0026gt;|skip a*|LR(aab,ab);\rLL--\u0026gt;|match a*|LLL(b,a*ab);\rLLL--\u0026gt;|skip a*|LLLL(b,ab);\rLL--\u0026gt;|skip a*|LLR(ab,ab);\rLR--\u0026gt;|match a|LRL(ab,b);\rLLR--\u0026gt;|match a|LLRL(b,b);\rLLRL--\u0026gt;|match b|LLRLL([END]);\rend\rDyamic Programming First we can construct state transision from the backtracking method. Jut let search(si, pi) to be dp[si][pi]\n1 2 3 4  dp[si][pi] \u0026lt;--------------- dp[si][pi+2]\r^ \\\r| \\ dp[si+1][pi] dp[si+1][pi+1]\r   We have a (len(s) + 1, len(p) +1) matrix, the iteration order is described below. Starting from dp[len(s)][len(p)-1], we need to get dp[0][0] Set dp[len(s)][len(p)] = True, which indicates our backtracking terminal condition(find a match).     s\\p c * a * a b      a end      F   a       F   b       F         start T    The core logic is pretty straightforward like backtracking solution:\n1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution:\rdef isMatch(self, s: str, p: str) -\u0026gt; bool:\rdp: List[List[bool]] = [[False]*(len(p)+1) for _ in range(len(s)+1)]\rdp[len(s)][len(p)] = True\rfor si in range(len(s), -1, -1):\rfor pi in range(len(p)-1, -1, -1):\rwildcard: bool = pi+1 \u0026lt; len(p) and p[pi+1] == \u0026#34;*\u0026#34;\rmatch: bool = si \u0026lt; len(s) and p[pi] in {s[si], \u0026#34;.\u0026#34;}\rif wildcard:\rdp[si][pi] = (match and dp[si+1][pi]) or dp[si][pi+2]\relse:\rdp[si][pi] = match and dp[si+1][pi+1]\rreturn dp[0][0]\r  Notes:\n This is similar to Distinct Subsequences ","description":"","id":28,"section":"playground","tags":["dynamic programming","backtracking"],"title":"Regular Expression Matching","uri":"/playground/regular-expression-matching/"},{"content":"MathJax  A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.\n When \\(a \\ne 0\\), there are two solutions to \\((ax^2 + bx + c = 0)\\) and they are \\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\]\nChartJS  Simple yet flexible JavaScript charting for designers \u0026amp; developers\n {\r\u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8]\r}]\r}\r}\r{\r\u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;,\r\u0026quot;data\u0026quot;: {\r\u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;],\r\u0026quot;datasets\u0026quot;: [\r{\r\u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;,\r\u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot;\r},\r{\r\u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;,\r\u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9],\r\u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;,\r\u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot;\r}\r]\r}\r}\rFLowChart  flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.\n st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank]\re=\u0026gt;end: End|future:\u0026gt;http://www.google.com\rop1=\u0026gt;operation: My Operation|past\rop2=\u0026gt;operation: Stuff|current\rsub1=\u0026gt;subroutine: My Subroutine|invalid\rcond=\u0026gt;condition: Yes\ror No?|approved:\u0026gt;http://www.google.com\rc2=\u0026gt;condition: Good idea|rejected\rio=\u0026gt;inputoutput: catch something...|future\rst-\u0026gt;op1(right)-\u0026gt;cond\rcond(yes, right)-\u0026gt;c2\rcond(no)-\u0026gt;sub1(left)-\u0026gt;op1\rc2(yes)-\u0026gt;io-\u0026gt;e\rc2(no)-\u0026gt;op2-\u0026gt;e\rJS Sequence Diagram support  Generates UML sequence diagrams from simple text\n Alice-\u0026gt;Bob: Hello Bob, how are you?\rNote right of Bob: Bob thinks\rBob--\u0026gt;Alice: I am good thanks!\rTitle: Here is a title\rA-\u0026gt;B: Normal line\rB--\u0026gt;C: Dashed line\rC-\u0026gt;\u0026gt;D: Open arrow\rD--\u0026gt;\u0026gt;A: Dashed open arrow\rKaTex  KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.\n The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\rInline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math:\r$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\rBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nMermaid  Generate diagrams, charts, graphs or flows from markdown-like text via javascript.\n graph TD;\rA--\u0026gt;B;\rA--\u0026gt;C;\rB--\u0026gt;D;\rC--\u0026gt;D;\rsequenceDiagram\rparticipant Alice\rparticipant Bob\rAlice-\u0026gt;John: Hello John, how are you?\rloop Healthcheck\rJohn-\u0026gt;John: Fight against hypochondria\rend\rNote right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail...\rJohn--\u0026gt;Alice: Great!\rJohn-\u0026gt;Bob: How about you?\rBob--\u0026gt;John: Jolly good!\rgraph TD\rA[Hard] --\u0026gt;|Text| B(Round)\rB --\u0026gt; C{Decision}\rC --\u0026gt;|One| D[Result 1]\rC --\u0026gt;|Two| E[Result 2]\rgantt\rsection Section\rCompleted :done, des1, 2014-01-06,2014-01-08\rActive :active, des2, 2014-01-07, 3d\rParallel 1 : des3, after des1, 1d\rParallel 2 : des4, after des1, 1d\rParallel 3 : des5, after des3, 1d\rParallel 4 : des6, after des4, 1d\rclassDiagram\rClass01 \u0026lt;|-- AveryLongClass : Cool\r\u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01\rClass09 --\u0026gt; C2 : Where am i?\rClass09 --* C3\rClass09 --|\u0026gt; Class07\rClass07 : equals()\rClass07 : Object[] elementData\rClass01 : size()\rClass01 : int chimp\rClass01 : int gorilla\rclass Class10 {\r\u0026lt;\u0026lt;service\u0026gt;\u0026gt;\rint id\rsize()\r}\rstateDiagram\r[*] --\u0026gt; Still\rStill --\u0026gt; [*]\rStill --\u0026gt; Moving\rMoving --\u0026gt; Still\rMoving --\u0026gt; Crash\rCrash --\u0026gt; [*]\rpie\r\u0026quot;Dogs\u0026quot; : 386\r\u0026quot;Cats\u0026quot; : 85\r\u0026quot;Rats\u0026quot; : 15 Wavedrom support  WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.\n { \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;},\r{\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]},\r{\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;},\r{},\r{\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;}\r]}\r","description":"Sample article showcasing test features like charts and latex equations.","id":29,"section":"blogs","tags":["markdown"],"title":"Library Support Guidance","uri":"/blogs/lib-guidance/"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn: Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nEmoji Support Emoji can be enabled in a Hugo project in a number of ways.\n\rThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji {\rfont-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols;\r}   Math TypeSetting We need goldmark katex entension which is not yet we have: [https://github.com/gohugoio/hugo/issues/6544](https://github.com/gohugoio/hugo/issues/6544)\r Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\n\rIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }}\r{{ partial \u0026quot;math.html\u0026quot; . }}\r{{ end }}\r To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $\nBlock math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\nRich Content Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nShort Codes Markdownify box This is boxmd shortcode Simple box This is **box** shortcode\r Code tabs Make it easy to switch between different code\njava\rjavascript\r\r1  System.out.println(\u0026#39;Hello World!\u0026#39;);\r  \r\r1  console.log(\u0026#39;Hello World!\u0026#39;);\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"c3a7395d19726e47\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Tabs for general purpose Windows\rMacOS\rUbuntu\r\rWindows section 1  console.log(\u0026#39;Hello World!\u0026#39;);\r  ⚠️Becareful that the content in the tab should be different from each other. The tab makes unique id hashes depending on the tab contents. So, If you just copy-paste the tabs with multiple times, since it has the same contents, the tab will not work.\n\rMacOS section Hello world!\r\rUbuntu section Great!\r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"226ccf8f521ab9fd\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar tabLinks = null;\rvar tabContents = null;\rvar ids = [];\rif (containerElem) {\rtabLinks = containerElem.querySelectorAll('.tab__link');\rtabContents = containerElem.querySelectorAll('.tab__content');\r}\rfor (var i = 0; i 0) {\rtabContents[0].style.display = 'block';\r}\r Expand \r\rExpand me\r\rTitle contents\r\r \r\rExpand me2\r\rTitle2 contents2\r\r Alert Colored box\nthis is a text\rthis is a text\rthis is a text\rthis is a text\rNotice success text\r info text\r warning text\r error text\r Code Syntax Highlighting Verify the following code blocks render as code blocks and highlight properly.\nDiff 1 2 3 4 5 6 7 8 9 10  *** /path/to/original\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39;\r--- /path/to/new\t\u0026#39;\u0026#39;timestamp\u0026#39;\u0026#39;\r***************\r*** 1 ****\r! This is a line.\r--- 1 ---\r! This is a replacement line.\rIt is important to spell\r-removed line\r+new line\r  Makefile 1 2 3 4 5  CC=gcc\rCFLAGS=-I.\rhellomake: hellomake.o hellofunc.o\r$(CC) -o hellomake hellomake.o hellofunc.o -I.\r  JSON 1 2 3  {\u0026#34;employees\u0026#34;:[\r{\u0026#34;firstName\u0026#34;:\u0026#34;John\u0026#34;, \u0026#34;lastName\u0026#34;:\u0026#34;Doe\u0026#34;},\r]}\r  Markdown 1 2 3  **bold** *italics* [link](www.example.com)\r  JavaScript 1  document.write(\u0026#39;Hello, world!\u0026#39;);\r  CSS 1 2 3  body {\rbackground-color: red;\r}\r  Objective C 1 2 3 4 5 6  #import \u0026lt;stdio.h\u0026gt;\r\rint main (void)\r{\rprintf (\u0026#34;Hello world!\\n\u0026#34;);\r}\r  Python 1  print \u0026#34;Hello, world!\u0026#34;\r  XML 1 2 3 4 5  \u0026lt;employees\u0026gt;\r\u0026lt;employee\u0026gt;\r\u0026lt;firstName\u0026gt;John\u0026lt;/firstName\u0026gt; \u0026lt;lastName\u0026gt;Doe\u0026lt;/lastName\u0026gt;\r\u0026lt;/employee\u0026gt;\r\u0026lt;/employees\u0026gt;\r  Perl 1  print \u0026#34;Hello, World!\\n\u0026#34;;\r  Bash 1  echo \u0026#34;Hello World\u0026#34;\r  PHP 1  \u0026lt;?php echo \u0026#39;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026#39;; ?\u0026gt;   CoffeeScript 1  console.log(“Hello world!”);\r  C# 1 2 3 4 5 6 7 8  using System;\rclass Program\r{\rpublic static void Main(string[] args)\r{\rConsole.WriteLine(\u0026#34;Hello, world!\u0026#34;);\r}\r}\r  C++ 1 2 3 4 5 6 7  #include \u0026lt;iostream.h\u0026gt;\r\rmain()\r{\rcout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34;;\rreturn 0;\r}\r  SQL 1 2  SELECT column_name,column_name\rFROM table_name;\r  Go 1 2 3 4 5  package main\rimport \u0026#34;fmt\u0026#34;\rfunc main() {\rfmt.Println(\u0026#34;Hello, 世界\u0026#34;)\r}\r  Ruby 1  puts \u0026#34;Hello, world!\u0026#34;\r  Java 1 2 3 4 5 6 7 8 9 10 11 12  import javax.swing.JFrame; //Importing class JFrame\rimport javax.swing.JLabel; //Importing class JLabel\rpublic class HelloWorld {\rpublic static void main(String[] args) {\rJFrame frame = new JFrame(); //Creating frame\r frame.setTitle(\u0026#34;Hi!\u0026#34;); //Setting title frame\r frame.add(new JLabel(\u0026#34;Hello, world!\u0026#34;));//Adding text to frame\r frame.pack(); //Setting size to smallest\r frame.setLocationRelativeTo(null); //Centering frame\r frame.setVisible(true); //Showing frame\r }\r}\r  Latex Equation 1  \\frac{d}{dx}\\left( \\int_{0}^{x} f(u)\\,du\\right)=f(x).\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import {x, y} as p from \u0026#39;point\u0026#39;;\rconst ANSWER = 42;\rclass Car extends Vehicle {\rconstructor(speed, cost) {\rsuper(speed);\rvar c = Symbol(\u0026#39;cost\u0026#39;);\rthis[c] = cost;\rthis.intro = `This is a car runs at\r${speed}.`;\r}\r}\rfor (let num of [1, 2, 3]) {\rconsole.log(num + 0b111110111);\r}\rfunction $initHighlight(block, flags) {\rtry {\rif (block.className.search(/\\bno\\-highlight\\b/) != -1)\rreturn processBlock(block.function, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;;\r} catch (e) {\r/* handle exception */\rvar e4x =\r\u0026lt;div\u0026gt;Example\r\u0026lt;p\u0026gt;1234\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;;\r }\rfor (var i = 0 / 2; i \u0026lt; classes.length; i++) {\r// \u0026#34;0 / 2\u0026#34; should not be parsed as regexp\r if (checkCondition(classes[i]) === undefined)\rreturn /\\d+[\\s/]/g;\r}\rconsole.log(Array.every(classes, Boolean));\r}\rexport $initHighlight;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\r\u0026lt;title\u0026gt;Hello world\u0026lt;/title\u0026gt;\r\u0026lt;link href=\u0026#39;http://fonts.googleapis.com/css?family=Roboto:400,400italic,700,700italic\u0026#39; rel=\u0026#39;stylesheet\u0026#39; type=\u0026#39;text/css\u0026#39;\u0026gt;\r\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;index.css\u0026#34; /\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\r\u0026lt;script src=\u0026#34;//cdnjs.cloudflare.com/ajax/libs/less.js/2.5.1/less.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;vendor/prism.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script src=\u0026#34;examples.bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  /*********************************************************\r* General\r*/\rpre[class*=\u0026#34;language-\u0026#34;],\rcode {\rcolor: #5c6e74;\rfont-size: 13px;\rtext-shadow: none;\rfont-family: Consolas, Monaco, \u0026#39;Andale Mono\u0026#39;, \u0026#39;Ubuntu Mono\u0026#39;, monospace;\rdirection: ltr;\rtext-align: left;\rwhite-space: pre;\rword-spacing: normal;\rword-break: normal;\rline-height: 1.5;\rtab-size: 4;\rhyphens: none;\r}\rpre[class*=\u0026#34;language-\u0026#34;]::selection,\rcode::selection {\rtext-shadow: none;\rbackground: #b3d4fc;\r}\r@media print {\rpre[class*=\u0026#34;language-\u0026#34;],\rcode {\rtext-shadow: none;\r}\r}\rpre[class*=\u0026#34;language-\u0026#34;] {\rpadding: 1em;\rmargin: .5em 0;\roverflow: auto;\rbackground: #f8f5ec;\r}\r:not(pre) \u0026gt; code {\rpadding: .1em .3em;\rborder-radius: .3em;\rcolor: #db4c69;\rbackground: #f9f2f4;\r}\r   The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","description":"Sample article showcasing basic Markdown syntax and formatting for HTML elements.","id":30,"section":"blogs","tags":["markdown"],"title":"Markdown Basic Syntax","uri":"/blogs/basic/"},{"content":"\n","description":"About xxuan.me backup site xxuan.cc","id":31,"section":"","tags":null,"title":"About","uri":"/about/"}]